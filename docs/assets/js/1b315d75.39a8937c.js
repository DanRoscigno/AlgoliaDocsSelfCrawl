"use strict";(self.webpackChunkclickhouse_docs_2_3_0=self.webpackChunkclickhouse_docs_2_3_0||[]).push([[92791],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),u=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=u(a),p=r,h=d["".concat(l,".").concat(p)]||d[p]||c[p]||i;return a?n.createElement(h,s(s({ref:t},m),{},{components:a})):n.createElement(h,s({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var u=2;u<i;u++)s[u]=a[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},29385:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var n=a(87462),r=(a(67294),a(3905));const i={slug:"/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design",sidebar_label:"ClickHouse Index Design",sidebar_position:2,description:"todo"},s="ClickHouse Index Design",o={unversionedId:"en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design",id:"en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design",title:"ClickHouse Index Design",description:"todo",source:"@site/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design.md",sourceDirName:"en/guides/improving-query-performance/sparse-primary-indexes",slug:"/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design",permalink:"/AlgoliaDocsSelfCrawl/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design",draft:!1,editUrl:"https://github.com/ClickHouse/clickhouse-docs/blob/main/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{slug:"/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design",sidebar_label:"ClickHouse Index Design",sidebar_position:2,description:"todo"},sidebar:"english",previous:{title:"Introduction",permalink:"/AlgoliaDocsSelfCrawl/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-intro"},next:{title:"Using multiple primary indexes",permalink:"/AlgoliaDocsSelfCrawl/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple"}},l={},u=[{value:"An index design for massive data scales",id:"an-index-design-for-massive-data-scales",level:2},{value:"A table with a primary key",id:"a-table-with-a-primary-key",level:2},{value:"Data is stored on disk ordered by primary key column(s)",id:"data-is-stored-on-disk-ordered-by-primary-key-columns",level:2},{value:"Data is organized into granules for parallel data processing",id:"data-is-organized-into-granules-for-parallel-data-processing",level:2},{value:"The primary index has one entry per granule",id:"the-primary-index-has-one-entry-per-granule",level:2},{value:"The primary index is used for selecting granules",id:"the-primary-index-is-used-for-selecting-granules",level:2},{value:"Mark files are used for locating granules",id:"mark-files-are-used-for-locating-granules",level:2}],m={toc:u},d="wrapper";function c(e){let{components:t,...i}=e;return(0,r.kt)(d,(0,n.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"clickhouse-index-design"},"ClickHouse Index Design"),(0,r.kt)("h2",{id:"an-index-design-for-massive-data-scales"},"An index design for massive data scales"),(0,r.kt)("p",null,"In traditional relational database management systems, the primary index would contain one entry per table row. For our data set this would result in the primary index - often a ",(0,r.kt)("a",{href:"https://en.wikipedia.org/wiki/B%2B_tree",target:"_blank"},"B(+)-Tree")," data structure - containing 8.87 million entries. Such an index allows the fast location of specific rows, resulting in high efficiency for lookup queries and point updates. Searching an entry in a B(+)-Tree data structure has average time complexity of ",(0,r.kt)("font",{face:"monospace"},"O(log2 n)"),". For a table of 8.87 million rows, this means 23 steps are required to locate any index entry. This capability comes at a cost: additional disk and memory overheads and higher insertion costs when adding new rows to the table and entries to the index (and also sometimes rebalancing of the B-Tree)."),(0,r.kt)("p",null,"Considering the challenges associated with B-Tree indexes, table engines in ClickHouse utilise a different approach. The ClickHouse ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/"},"MergeTree Engine Family")," has been designed and optimized to handle massive data volumes. These tables are designed to receive millions of row inserts per second and store very large (100s of Petabytes) volumes of data. Data is quickly written to a table ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage"},"part by part"),", with rules applied for merging the parts in the background. In ClickHouse each part has its own primary index. When parts are merged, then the merged part\u2019s primary indexes are also merged. At the very large scale that ClickHouse is designed for, it is paramount to be very disk and memory efficient. Therefore, instead of indexing every row, the primary index for a part has one index entry (known as a \u2018mark\u2019) per group of rows (called \u2018granule\u2019) - this technique is called ",(0,r.kt)("strong",{parentName:"p"},"sparse index"),"."),(0,r.kt)("p",null,"Sparse indexing is possible because ClickHouse is storing the rows for a part on disk ordered by the primary key column(s). Instead of directly locating single rows (like a B-Tree based index), the sparse primary index allows it to quickly (via a binary search over index entries) identify groups of rows that could possibly match the query. The located groups of potentially matching rows (granules) are then in parallel streamed into the ClickHouse engine in order to find the matches. This index design allows for the primary index to be small (it can, and must, completely fit into the main memory), whilst still significantly speeding up query execution times: especially for range queries that are typical in data analytics use cases."),(0,r.kt)("p",null,"The following illustrates in detail how ClickHouse is building and using its sparse primary index. Later on in the article, we will discuss some best practices for choosing, removing, and ordering the table columns that are used to build the index (primary key columns)."),(0,r.kt)("h2",{id:"a-table-with-a-primary-key"},"A table with a primary key"),(0,r.kt)("p",null,"Create a table that has a compound primary key with key columns UserID and URL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE hits_UserID_URL\n(\n    `UserID` UInt32,\n    `URL` String,\n    `EventTime` DateTime\n)\nENGINE = MergeTree\n// highlight-next-line\nPRIMARY KEY (UserID, URL)\nORDER BY (UserID, URL, EventTime)\nSETTINGS index_granularity = 8192, index_granularity_bytes = 0;\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("font",{color:"black"},"DDL Statement Details")),(0,r.kt)("p",null,(0,r.kt)("font",{color:"black"},(0,r.kt)("p",null,"In order to simplify the discussions later on in this guide, as well as  make the diagrams and results reproducible, the DDL statement"),(0,r.kt)("ul",null,(0,r.kt)("li",null,"specifies a compound sorting key for the table via an ",(0,r.kt)("font",{face:"monospace"},"ORDER BY")," clause"),(0,r.kt)("br",null),(0,r.kt)("li",null,"explicitly controls how many index entries the primary index will have through the settings:"),(0,r.kt)("br",null),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("font",{face:"monospace"},"index_granularity"),": explicitly set to its default value of 8192. This means that for each group of 8192 rows, the primary index will have one index entry, e.g. if the table contains 16384 rows then the index will have two index entries."),(0,r.kt)("br",null),(0,r.kt)("li",null,(0,r.kt)("font",{face:"monospace"},"index_granularity_bytes"),": set to 0 in order to disable ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/whats-new/changelog/2019/#experimental-features-1",target:"_blank"},(0,r.kt)("font",{color:"blue"},"adaptive index granularity")),". Adaptive index granularity means that ClickHouse automatically creates one index entry for a group of n rows if either of these are true:",(0,r.kt)("ul",null,(0,r.kt)("li",null,"if n is less than 8192 and the size of the combined row data for that n rows is larger than or equal to 10 MB (the default value for index_granularity_bytes) or"),(0,r.kt)("li",null,"if the combined row data size for n rows is less than 10 MB but n is 8192.")))))))),(0,r.kt)("p",null,"The primary key in the DDL statement above causes the creation of the primary index based on the two specified key columns."),(0,r.kt)("br",null),"Next insert the data:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO hits_UserID_URL SELECT\n   intHash32(UserID) AS UserID,\n   URL,\n   EventTime\nFROM url('https://datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz', 'TSV', 'WatchID UInt64,  JavaEnable UInt8,  Title String,  GoodEvent Int16,  EventTime DateTime,  EventDate Date,  CounterID UInt32,  ClientIP UInt32,  ClientIP6 FixedString(16),  RegionID UInt32,  UserID UInt64,  CounterClass Int8,  OS UInt8,  UserAgent UInt8,  URL String,  Referer String,  URLDomain String,  RefererDomain String,  Refresh UInt8,  IsRobot UInt8,  RefererCategories Array(UInt16),  URLCategories Array(UInt16), URLRegions Array(UInt32),  RefererRegions Array(UInt32),  ResolutionWidth UInt16,  ResolutionHeight UInt16,  ResolutionDepth UInt8,  FlashMajor UInt8, FlashMinor UInt8,  FlashMinor2 String,  NetMajor UInt8,  NetMinor UInt8, UserAgentMajor UInt16,  UserAgentMinor FixedString(2),  CookieEnable UInt8, JavascriptEnable UInt8,  IsMobile UInt8,  MobilePhone UInt8,  MobilePhoneModel String,  Params String,  IPNetworkID UInt32,  TraficSourceID Int8, SearchEngineID UInt16,  SearchPhrase String,  AdvEngineID UInt8,  IsArtifical UInt8,  WindowClientWidth UInt16,  WindowClientHeight UInt16,  ClientTimeZone Int16,  ClientEventTime DateTime,  SilverlightVersion1 UInt8, SilverlightVersion2 UInt8,  SilverlightVersion3 UInt32,  SilverlightVersion4 UInt16,  PageCharset String,  CodeVersion UInt32,  IsLink UInt8,  IsDownload UInt8,  IsNotBounce UInt8,  FUniqID UInt64,  HID UInt32,  IsOldCounter UInt8, IsEvent UInt8,  IsParameter UInt8,  DontCountHits UInt8,  WithHash UInt8, HitColor FixedString(1),  UTCEventTime DateTime,  Age UInt8,  Sex UInt8,  Income UInt8,  Interests UInt16,  Robotness UInt8,  GeneralInterests Array(UInt16), RemoteIP UInt32,  RemoteIP6 FixedString(16),  WindowName Int32,  OpenerName Int32,  HistoryLength Int16,  BrowserLanguage FixedString(2),  BrowserCountry FixedString(2),  SocialNetwork String,  SocialAction String,  HTTPError UInt16, SendTiming Int32,  DNSTiming Int32,  ConnectTiming Int32,  ResponseStartTiming Int32,  ResponseEndTiming Int32,  FetchTiming Int32,  RedirectTiming Int32, DOMInteractiveTiming Int32,  DOMContentLoadedTiming Int32,  DOMCompleteTiming Int32,  LoadEventStartTiming Int32,  LoadEventEndTiming Int32, NSToDOMContentLoadedTiming Int32,  FirstPaintTiming Int32,  RedirectCount Int8, SocialSourceNetworkID UInt8,  SocialSourcePage String,  ParamPrice Int64, ParamOrderID String,  ParamCurrency FixedString(3),  ParamCurrencyID UInt16, GoalsReached Array(UInt32),  OpenstatServiceName String,  OpenstatCampaignID String,  OpenstatAdID String,  OpenstatSourceID String,  UTMSource String, UTMMedium String,  UTMCampaign String,  UTMContent String,  UTMTerm String, FromTag String,  HasGCLID UInt8,  RefererHash UInt64,  URLHash UInt64,  CLID UInt32,  YCLID UInt64,  ShareService String,  ShareURL String,  ShareTitle String,  ParsedParams Nested(Key1 String,  Key2 String, Key3 String, Key4 String, Key5 String,  ValueDouble Float64),  IslandID FixedString(16),  RequestNum UInt32,  RequestTry UInt8')\nWHERE URL != '';\n")),(0,r.kt)("p",null,"The response looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-response"},"0 rows in set. Elapsed: 149.432 sec. Processed 8.87 million rows, 18.40 GB (59.38 thousand rows/s., 123.16 MB/s.)\n")),(0,r.kt)("br",null),"And optimize the table:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"OPTIMIZE TABLE hits_UserID_URL FINAL;\n")),(0,r.kt)("br",null),"We can use the following query to obtain metadata about our table:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT\n    part_type,\n    path,\n    formatReadableQuantity(rows) AS rows,\n    formatReadableSize(data_uncompressed_bytes) AS data_uncompressed_bytes,\n    formatReadableSize(data_compressed_bytes) AS data_compressed_bytes,\n    formatReadableSize(primary_key_bytes_in_memory) AS primary_key_bytes_in_memory,\n    marks,\n    formatReadableSize(bytes_on_disk) AS bytes_on_disk\nFROM system.parts\nWHERE (table = 'hits_UserID_URL') AND (active = 1)\nFORMAT Vertical;\n")),(0,r.kt)("p",null,"The response is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-response"},"part_type:                   Wide\npath:                        ./store/d9f/d9f36a1a-d2e6-46d4-8fb5-ffe9ad0d5aed/all_1_9_2/\nrows:                        8.87 million\ndata_uncompressed_bytes:     733.28 MiB\ndata_compressed_bytes:       206.94 MiB\nprimary_key_bytes_in_memory: 96.93 KiB\nmarks:                       1083\nbytes_on_disk:               207.07 MiB\n\n\n1 rows in set. Elapsed: 0.003 sec.\n")),(0,r.kt)("p",null,"The output of the ClickHouse client shows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The table\u2019s data is stored in ",(0,r.kt)("a",{parentName:"li",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage"},"wide format")," in a specific directory on disk meaning that there will be one data file (and one mark file) per table column inside that directory."),(0,r.kt)("li",{parentName:"ul"},"The table has 8.87 million rows."),(0,r.kt)("li",{parentName:"ul"},"The uncompressed data size of all rows together is 733.28 MB."),(0,r.kt)("li",{parentName:"ul"},"The compressed size on disk of all rows together is 206.94 MB."),(0,r.kt)("li",{parentName:"ul"},"The table has a primary index with 1083 entries (called \u2018marks\u2019) and the size of the index is 96.93 KB."),(0,r.kt)("li",{parentName:"ul"},"In total, the table\u2019s data and mark files and primary index file together take 207.07 MB on disk.")),(0,r.kt)("h2",{id:"data-is-stored-on-disk-ordered-by-primary-key-columns"},"Data is stored on disk ordered by primary key column(s)"),(0,r.kt)("p",null,"Our table that we created above has"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a compound ",(0,r.kt)("a",{parentName:"li",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#primary-keys-and-indexes-in-queries"},"primary key")," ",(0,r.kt)("font",{face:"monospace"},"(UserID, URL)")," and"),(0,r.kt)("li",{parentName:"ul"},"a compound ",(0,r.kt)("a",{parentName:"li",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#choosing-a-primary-key-that-differs-from-the-sorting-key"},"sorting key")," ",(0,r.kt)("font",{face:"monospace"},"(UserID, URL, EventTime)"),".")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If we would have specified only the sorting key, then the primary key would be implicitly defined to be equal to the sorting key.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In order to be memory efficient we explicitly specified a primary key that only contains columns that our queries are filtering on. The primary index that is based on the primary key is completely loaded into the main memory.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In order to have consistency in the guide\u2019s diagrams and in order to maximise compression ratio we defined a separate sorting key that includes all of our table's columns (if in a column similar data is placed close to each other, for example via sorting, then that data will be compressed better).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The primary key needs to be a prefix of the sorting key if both are specified.")))),(0,r.kt)("p",null,"The inserted rows are stored on disk in lexicographical order (ascending) by the primary key columns (and the additional EventTime column from the sorting key)."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"ClickHouse allows inserting multiple rows with identical primary key column values. In this case (see row 1 and row 2 in the diagram below), the final order is determined by the specified sorting key and therefore the value of the ",(0,r.kt)("font",{face:"monospace"},"EventTime")," column.")),(0,r.kt)("p",null,"ClickHouse is a ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/introduction/distinctive-features/#true-column-oriented-dbms\n",target:"_blank"},"column-oriented database management system"),". As shown in the diagram below"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"for the on disk representation, there is a single data file (*.bin) per table column where all the values for that column are stored in a ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression",target:"_blank"},"compressed")," format, and"),(0,r.kt)("li",{parentName:"ul"},"the 8.87 million rows are stored on disk in lexicographic ascending order by the primary key columns (and the additional sort key columns) i.e. in this case",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"first by ",(0,r.kt)("font",{face:"monospace"},"UserID"),","),(0,r.kt)("li",{parentName:"ul"},"then by ",(0,r.kt)("font",{face:"monospace"},"URL"),","),(0,r.kt)("li",{parentName:"ul"},"and lastly by ",(0,r.kt)("font",{face:"monospace"},"EventTime"),":")))),(0,r.kt)("img",{src:a(45231).Z,class:"image"}),"UserID.bin, URL.bin, and EventTime.bin are the data files on disk where the values of the ",(0,r.kt)("font",{face:"monospace"},"UserID"),", ",(0,r.kt)("font",{face:"monospace"},"URL"),", and ",(0,r.kt)("font",{face:"monospace"},"EventTime")," columns are stored.",(0,r.kt)("br",null),(0,r.kt)("br",null),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"As the primary key defines the lexicographical order of the rows on disk, a table can only have one primary key.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We are numbering rows starting with 0 in order to be aligned with the ClickHouse internal row numbering scheme that is also used for logging messages.")))),(0,r.kt)("h2",{id:"data-is-organized-into-granules-for-parallel-data-processing"},"Data is organized into granules for parallel data processing"),(0,r.kt)("p",null,"For data processing purposes, a table's column values are logically divided into granules.\nA granule is the smallest indivisible data set that is streamed into ClickHouse for data processing.\nThis means that instead of reading individual rows, ClickHouse is always reading (in a streaming fashion and in parallel) a whole group (granule) of rows."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Column values are not physically stored inside granules: granules are just a logical organization of the column values for query processing.")),(0,r.kt)("p",null,"The following diagram shows how the (column values of) 8.87 million rows of our table\nare organized into 1083 granules, as a result of the table's DDL statement containing the setting ",(0,r.kt)("font",{face:"monospace"},"index_granularity")," (set to its default value of 8192)."),(0,r.kt)("img",{src:a(37705).Z,class:"image"}),(0,r.kt)("p",null,"The first (based on physical order on disk) 8192 rows (their column values) logically belong to granule 0, then the next 8192 rows (their column values) belong to granule 1 and so on."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'The last granule (granule 1082) "contains" less than 8192 rows.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'We mentioned in the beginning of this guide in the "DDL Statement Details", that we disabled ',(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/whats-new/changelog/2019/#experimental-features-1"},"adaptive index granularity")," (in order to simplify the discussions in this guide, as well as make the diagrams and results reproducible)."),(0,r.kt)("p",{parentName:"li"},"Therefore all granules (except the last one) of our example table have the same size.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For tables with adaptive index granularity (index granularity is adaptive by ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#index_granularity_bytes"},"default"),") the size of some granules can be less than 8192 rows depending on the row data sizes. "))),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We marked some column values from our primary key columns (",(0,r.kt)("font",{face:"monospace"},"UserID"),", ",(0,r.kt)("font",{face:"monospace"},"URL"),") in orange.\nThese orange-marked column values are the primary key column values of each first row of each granule.\nAs we will see below, these orange-marked column values will be the entries in the table's primary index.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We are numbering granules starting with 0 in order to be aligned with the ClickHouse internal numbering scheme that is also used for logging messages.")))),(0,r.kt)("h2",{id:"the-primary-index-has-one-entry-per-granule"},"The primary index has one entry per granule"),(0,r.kt)("p",null,"The primary index is created based on the granules shown in the diagram above. This index is an uncompressed flat array file (primary.idx), containing so-called numerical index marks starting at 0."),(0,r.kt)("p",null,"The diagram below shows that the index stores the primary key column values (the values marked in orange in the diagram above) for each first row for each granule.\nOr in other words: the primary index stores the primary key column values from each 8192nd row of the table (based on the physical row order defined by the primary key columns).\nFor example"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the first index entry (\u2018mark 0\u2019 in the diagram below) is storing the key column values of the first row of granule 0 from the diagram above,"),(0,r.kt)("li",{parentName:"ul"},"the second index entry (\u2018mark 1\u2019 in the diagram below) is storing the key column values of the first row of granule 1 from the diagram above, and so on.")),(0,r.kt)("img",{src:a(72661).Z,class:"image"}),(0,r.kt)("p",null,"In total the index has 1083 entries for our table with 8.87 million rows and 1083 granules:"),(0,r.kt)("img",{src:a(77695).Z,class:"image"}),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For tables with ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/whats-new/changelog/2019/#experimental-features-1"},"adaptive index granularity"),', there is also one "final" additional mark stored in the primary index that records the values of the primary key columns of the last table row, but because we disabled adaptive index granularity (in order to simplify the discussions in this guide, as well as make the diagrams and results reproducible), the index of our example table doesn\'t include this final mark.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The primary index file is completely loaded into the main memory. If the file is larger than the available free memory space then ClickHouse will raise an error.")))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("font",{color:"black"},"Inspecting the content of the primary index")),(0,r.kt)("p",null,(0,r.kt)("font",{color:"black"},(0,r.kt)("p",null,"On a self-managed ClickHouse cluster we can use the ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/sql-reference/table-functions/file/",target:"_blank"},(0,r.kt)("font",{color:"blue"},"file table function"))," for inspecting the content of the primary index of our example table."),(0,r.kt)("p",null,"For that we first need to copy the primary index file into the ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-user_files_path",target:"_blank"},(0,r.kt)("font",{color:"blue"},"user_files_path"))," of a node from the running cluster:"),(0,r.kt)("ul",null,(0,r.kt)("li",null,"Step 1: Get part-path that contains the primary index file"),(0,r.kt)("font",{face:"monospace"},"SELECT path FROM system.parts WHERE table = 'hits_UserID_URL' AND active = 1"),(0,r.kt)("p",null,"returns ",(0,r.kt)("font",{face:"monospace"},"/Users/tomschreiber/Clickhouse/store/85f/85f4ee68-6e28-4f08-98b1-7d8affa1d88c/all_1_9_4")," on the test machine."),(0,r.kt)("li",null,"Step 2: Get user_files_path"),"The ",(0,r.kt)("a",{href:"https://github.com/ClickHouse/ClickHouse/blob/22.12/programs/server/config.xml#L505",target:"_blank"},(0,r.kt)("font",{color:"blue"},"default user_files_path"))," on Linux is",(0,r.kt)("font",{face:"monospace"},"/var/lib/clickhouse/user_files/"),(0,r.kt)("p",null,"and on Linux you can check if it got changed: ",(0,r.kt)("font",{face:"monospace"},"$ grep user_files_path /etc/clickhouse-server/config.xml")),(0,r.kt)("p",null,"On the test machine the path is ",(0,r.kt)("font",{face:"monospace"},"/Users/tomschreiber/Clickhouse/user_files/")),(0,r.kt)("li",null,"Step 3: Copy the primary index file into the user_files_path"),(0,r.kt)("font",{face:"monospace"},"cp /Users/tomschreiber/Clickhouse/store/85f/85f4ee68-6e28-4f08-98b1-7d8affa1d88c/all_1_9_4/primary.idx /Users/tomschreiber/Clickhouse/user_files/primary-hits_UserID_URL.idx"),(0,r.kt)("br",null)),(0,r.kt)("p",null,"Now we can inspect the content of the primary index via SQL:"),(0,r.kt)("ul",null,(0,r.kt)("li",null,"Get amount of entries"),(0,r.kt)("font",{face:"monospace"},"SELECT count( )",(0,r.kt)("br",null),"FROM file('primary-hits_UserID_URL.idx', 'RowBinary', 'UserID UInt32, URL String');"),(0,r.kt)("br",null),(0,r.kt)("br",null),"returns ",(0,r.kt)("font",{face:"monospace"},"1083"),(0,r.kt)("br",null),(0,r.kt)("br",null),(0,r.kt)("li",null,"Get first two index marks"),(0,r.kt)("font",{face:"monospace"},"SELECT UserID, URL",(0,r.kt)("br",null),"FROM file('primary-hits_UserID_URL.idx', 'RowBinary', 'UserID UInt32, URL String')",(0,r.kt)("br",null),"LIMIT 0, 2;"),(0,r.kt)("br",null),(0,r.kt)("br",null),"returns",(0,r.kt)("br",null),(0,r.kt)("font",{face:"monospace"},"240923, http://showtopics.html%3...",(0,r.kt)("br",null),"4073710, http://mk.ru&pos=3_0"),(0,r.kt)("br",null),(0,r.kt)("br",null),(0,r.kt)("li",null,"Get last index mark"),(0,r.kt)("font",{face:"monospace"},"SELECT UserID, URL",(0,r.kt)("br",null),"FROM file('primary-hits_UserID_URL.idx', 'RowBinary', 'UserID UInt32, URL String')",(0,r.kt)("br",null),"LIMIT 1082, 1;"),(0,r.kt)("br",null),(0,r.kt)("br",null),"returns",(0,r.kt)("br",null),(0,r.kt)("font",{face:"monospace"},"4292714039 \u2502 http://sosyal-mansetleri...")),(0,r.kt)("p",null,"This matches exactly our diagram of the primary index content for our example table:"),(0,r.kt)("img",{src:a(77695).Z,class:"image"})))),(0,r.kt)("p",null,"The primary key entries are called index marks because each index entry is marking the start of a specific data range. Specifically for the example table:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"UserID index marks:",(0,r.kt)("br",null),"\nThe stored ",(0,r.kt)("font",{face:"monospace"},"UserID")," values in the primary index are sorted in ascending order.",(0,r.kt)("br",null),"\n\u2018mark 1\u2019 in the diagram above thus indicates that the ",(0,r.kt)("font",{face:"monospace"},"UserID")," values of all table rows in granule 1, and in all following granules, are guaranteed to be greater than or equal to 4.073.710."),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#the-primary-index-is-used-for-selecting-granules"},"As we will see later"),", this global order enables ClickHouse to ",(0,r.kt)("a",{href:"https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452",target:"_blank"},"use a binary search algorithm")," over the index marks for the first key column when a query is filtering on the first column of the primary key.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"URL index marks:",(0,r.kt)("br",null),"\nThe quite similar cardinality of the primary key columns ",(0,r.kt)("font",{face:"monospace"},"UserID")," and ",(0,r.kt)("font",{face:"monospace"},"URL"),"\nmeans that the index marks for all key columns after the first column in general only indicate a data range as long as the predecessor key column value stays the same for all table rows within at least the current granule.",(0,r.kt)("br",null),"\nFor example, because the UserID values of mark 0 and mark 1 are different in the diagram above, ClickHouse can't assume that all URL values of all table rows in granule 0 are larger or equal to ",(0,r.kt)("font",{face:"monospace"},"'",(0,r.kt)("a",{parentName:"p",href:"http://showtopics.html%253...'"},"http://showtopics.html%3...'")),". However, if the UserID values of mark 0 and mark 1 would be the same in the diagram above (meaning that the UserID value stays the same for all table rows within the granule 0), the ClickHouse could assume that all URL values of all table rows in granule 0 are larger or equal to ",(0,r.kt)("font",{face:"monospace"},"'",(0,r.kt)("a",{parentName:"p",href:"http://showtopics.html%253...'"},"http://showtopics.html%3...'")),"."),(0,r.kt)("p",{parentName:"li"}," We will discuss the consequences of this on query execution performance in more detail later."))),(0,r.kt)("h2",{id:"the-primary-index-is-used-for-selecting-granules"},"The primary index is used for selecting granules"),(0,r.kt)("p",null,"We can now execute our queries with support from the primary index."),(0,r.kt)("p",null,"The following calculates the top 10 most clicked urls for the UserID 749927693."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT URL, count(URL) AS Count\nFROM hits_UserID_URL\nWHERE UserID = 749927693\nGROUP BY URL\nORDER BY Count DESC\nLIMIT 10;\n")),(0,r.kt)("p",null,"The response is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-response"},"\u250c\u2500URL\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500Count\u2500\u2510\n\u2502 http://auto.ru/chatay-barana.. \u2502   170 \u2502\n\u2502 http://auto.ru/chatay-id=371...\u2502    52 \u2502\n\u2502 http://public_search           \u2502    45 \u2502\n\u2502 http://kovrik-medvedevushku-...\u2502    36 \u2502\n\u2502 http://forumal                 \u2502    33 \u2502\n\u2502 http://korablitz.ru/L_1OFFER...\u2502    14 \u2502\n\u2502 http://auto.ru/chatay-id=371...\u2502    14 \u2502\n\u2502 http://auto.ru/chatay-john-D...\u2502    13 \u2502\n\u2502 http://auto.ru/chatay-john-D...\u2502    10 \u2502\n\u2502 http://wot/html?page/23600_m...\u2502     9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n10 rows in set. Elapsed: 0.005 sec.\n// highlight-next-line\nProcessed 8.19 thousand rows,\n740.18 KB (1.53 million rows/s., 138.59 MB/s.)\n")),(0,r.kt)("p",null,"The output for the ClickHouse client is now showing that instead of doing a full table scan, only 8.19 thousand rows were streamed into ClickHouse."),(0,r.kt)("p",null,"If ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/#server_configuration_parameters-logger",target:"_blank"},"trace logging")," is enabled then the ClickHouse server log file shows that ClickHouse was running a ",(0,r.kt)("a",{href:"https://github.com/ClickHouse/ClickHouse/blob/22.3/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp#L1452",target:"_blank"},"binary search")," over the 1083 UserID index marks, in order to identify granules that possibly can contain rows with a UserID column value of ",(0,r.kt)("font",{face:"monospace"},"749927693"),". This requires 19 steps with an average time complexity of ",(0,r.kt)("font",{face:"monospace"},"O(log2 n)"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-response"},"...Executor): Key condition: (column 0 in [749927693, 749927693])\n// highlight-next-line\n...Executor): Running binary search on index range for part all_1_9_2 (1083 marks)\n...Executor): Found (LEFT) boundary mark: 176\n...Executor): Found (RIGHT) boundary mark: 177\n...Executor): Found continuous range in 19 steps\n...Executor): Selected 1/1 parts by partition key, 1 parts by primary key,\n// highlight-next-line\n              1/1083 marks by primary key, 1 marks to read from 1 ranges\n...Reading ...approx. 8192 rows starting from 1441792\n")),(0,r.kt)("p",null,"We can see in the trace log above, that one mark out of the 1083 existing marks satisfied the query."),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("font",{color:"black"},"Trace Log Details")),(0,r.kt)("p",null,(0,r.kt)("font",{color:"black"},(0,r.kt)("p",null,"Mark 176 was identified (the 'found left boundary mark' is inclusive, the 'found right boundary mark' is exclusive), and therefore all 8192 rows from granule 176 (which starts at row 1.441.792 - we will see that later on in this guide) are then streamed into ClickHouse in order to find the actual rows with a UserID column value of ",(0,r.kt)("font",{face:"monospace"},"749927693"),".")))),(0,r.kt)("p",null,"We can also reproduce this by using the ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/sql-reference/statements/explain/",target:"_blank"},"EXPLAIN clause")," in our example query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"EXPLAIN indexes = 1\nSELECT URL, count(URL) AS Count\nFROM hits_UserID_URL\nWHERE UserID = 749927693\nGROUP BY URL\nORDER BY Count DESC\nLIMIT 10;\n")),(0,r.kt)("p",null,"The response looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-response"},"\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Expression (Projection)                                                               \u2502\n\u2502   Limit (preliminary LIMIT (without OFFSET))                                          \u2502\n\u2502     Sorting (Sorting for ORDER BY)                                                    \u2502\n\u2502       Expression (Before ORDER BY)                                                    \u2502\n\u2502         Aggregating                                                                   \u2502\n\u2502           Expression (Before GROUP BY)                                                \u2502\n\u2502             Filter (WHERE)                                                            \u2502\n\u2502               SettingQuotaAndLimits (Set limits and quota after reading from storage) \u2502\n\u2502                 ReadFromMergeTree                                                     \u2502\n\u2502                 Indexes:                                                              \u2502\n\u2502                   PrimaryKey                                                          \u2502\n\u2502                     Keys:                                                             \u2502\n\u2502                       UserID                                                          \u2502\n\u2502                     Condition: (UserID in [749927693, 749927693])                     \u2502\n\u2502                     Parts: 1/1                                                        \u2502\n// highlight-next-line\n\u2502                     Granules: 1/1083                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n16 rows in set. Elapsed: 0.003 sec.\n")),(0,r.kt)("p",null,"The client output is showing that one out of the 1083 granules was selected as possibly containing rows with a UserID column value of 749927693."),(0,r.kt)("admonition",{title:"Conclusion",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"When a query is filtering on a column that is part of a compound key and is the first key column, then ClickHouse is running the binary search algorithm over the key column's index marks.")),(0,r.kt)("br",null),(0,r.kt)("p",null,"As discussed above, ClickHouse is using its sparse primary index for quickly (via binary search) selecting granules that could possibly contain rows that match a query."),(0,r.kt)("p",null,"This is the ",(0,r.kt)("strong",{parentName:"p"},"first stage (granule selection)")," of ClickHouse query execution."),(0,r.kt)("p",null,"In the ",(0,r.kt)("strong",{parentName:"p"},"second stage (data reading)"),", ClickHouse is locating the selected granules in order to stream all their rows into the ClickHouse engine in order to find the rows that are actually matching the query."),(0,r.kt)("p",null,"We discuss that second stage in more detail in the following section."),(0,r.kt)("h2",{id:"mark-files-are-used-for-locating-granules"},"Mark files are used for locating granules"),(0,r.kt)("p",null,"The following diagram illustrates a part of the primary index file for our table."),(0,r.kt)("img",{src:a(39e3).Z,class:"image"}),(0,r.kt)("p",null,"As discussed above, via a binary search over the index\u2019s 1083 UserID marks, mark 176 was identified. Its corresponding granule 176 can therefore possibly contain rows with a UserID column value of 749.927.693."),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("font",{color:"black"},"Granule Selection Details")),(0,r.kt)("p",null,(0,r.kt)("font",{color:"black"},(0,r.kt)("p",null,"The diagram above shows that mark 176 is the first index entry where both the minimum UserID value of the associated granule 176 is smaller than 749.927.693, and the minimum UserID value of granule 177 for the next mark (mark 177) is greater than this value. Therefore only the corresponding granule 176 for mark 176 can possibly contain rows with a UserID column value of 749.927.693.")))),(0,r.kt)("p",null,"In order to confirm (or not) that some row(s) in granule 176 contain a UserID column value of 749.927.693, all 8192 rows belonging to this granule need to be streamed into ClickHouse."),(0,r.kt)("p",null,"To achieve this, ClickHouse needs to know the physical location of granule 176."),(0,r.kt)("p",null,"In ClickHouse the physical locations of all granules for our table are stored in mark files. Similar to data files, there is one mark file per table column."),(0,r.kt)("p",null,"The following diagram shows the three mark files UserID.mrk, URL.mrk, and EventTime.mrk that store the physical locations of the granules for the table\u2019s UserID, URL, and EventTime columns."),(0,r.kt)("img",{src:a(94774).Z,class:"image"}),(0,r.kt)("p",null,"We have discussed how the primary index is a flat uncompressed array file (primary.idx), containing index marks that are numbered starting at 0."),(0,r.kt)("p",null,"Similarly, a mark file is also a flat uncompressed array file (*.mrk) containing marks that are numbered starting at 0."),(0,r.kt)("p",null,"Once ClickHouse has identified and selected the index mark for a granule that can possibly contain matching rows for a query, a positional array lookup can be performed in the mark files in order to obtain the physical locations of the granule."),(0,r.kt)("p",null,"Each mark file entry for a specific column is storing two locations in the form of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The first offset ('block_offset' in the diagram above) is locating the ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/development/architecture/#block",target:"_blank"},"block")," in the ",(0,r.kt)("a",{href:"https://clickhouse.com/docs/en/introduction/distinctive-features/#data-compression",target:"_blank"},"compressed")," column data file that contains the compressed version of the selected granule. This compressed block potentially contains a few compressed granules. The located compressed file block is uncompressed into the main memory on read.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The second offset ('granule_offset' in the diagram above) from the mark-file provides the location of the granule within the uncompressed block data."))),(0,r.kt)("p",null,"All the 8192 rows belonging to the located uncompressed granule are then streamed into ClickHouse for further processing."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For tables with ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage"},"wide format")," and without ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/whats-new/changelog/2019/#experimental-features-1"},"adaptive index granularity"),", ClickHouse uses ",(0,r.kt)("font",{face:"monospace"},".mrk")," mark files as visualised above, that contain entries with two 8 byte long addresses per entry. These entries are physical locations of granules that all have the same size.  "),(0,r.kt)("p",{parentName:"li"},"Index granularity is adaptive by ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#index_granularity_bytes"},"default"),", but for our example table we disabled adaptive index granularity (in order to simplify the discussions in this guide, as well as make the diagrams and results reproducible). Our table is using wide format because the size of the data is larger than ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#min_bytes_for_wide_part"},"min_bytes_for_wide_part")," (which is 10 MB by default for self-managed clusters).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For tables with wide format and with adaptive index granularity, ClickHouse uses ",(0,r.kt)("font",{face:"monospace"},".mrk2")," mark files, that contain similar entries to ",(0,r.kt)("font",{face:"monospace"},".mrk")," mark files but with an additional third value per entry: the number of rows of the granule that the current entry is associated with.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For tables with ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#mergetree-data-storage"},"compact format"),", ClickHouse uses ",(0,r.kt)("font",{face:"monospace"},".mrk3")," mark files.")))),(0,r.kt)("admonition",{title:"Why Mark Files",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Why does the primary index not directly contain the physical locations of the granules that are corresponding to index marks?"),(0,r.kt)("p",{parentName:"admonition"},"Because at that very large scale that ClickHouse is designed for, it is important to be very disk and memory efficient."),(0,r.kt)("p",{parentName:"admonition"},"The primary index file needs to fit into the main memory."),(0,r.kt)("p",{parentName:"admonition"},"For our example query, ClickHouse used the primary index and selected a single granule that can possibly contain rows matching our query. Only for that one granule does ClickHouse then need the physical locations in order to stream the corresponding rows for further processing."),(0,r.kt)("p",{parentName:"admonition"},"Furthermore, this offset information is only needed for the UserID and URL columns."),(0,r.kt)("p",{parentName:"admonition"},"Offset information is not needed for columns that are not used in the query e.g. the EventTime."),(0,r.kt)("p",{parentName:"admonition"},"For our sample query, ClickHouse needs only the two physical location offsets for granule 176 in the UserID data file (UserID.bin) and the two physical location offsets for granule 176 in the URL data file (URL.bin)."),(0,r.kt)("p",{parentName:"admonition"},"The indirection provided by mark files avoids storing, directly within the primary index, entries for the physical locations of all 1083 granules for all three columns: thus avoiding having unnecessary (potentially unused) data in main memory.")),(0,r.kt)("p",null,"The following diagram and the text below illustrate how for our example query ClickHouse locates granule 176 in the UserID.bin data file."),(0,r.kt)("img",{src:a(20990).Z,class:"image"}),(0,r.kt)("p",null,"We discussed earlier in this guide that ClickHouse selected the primary index mark 176 and therefore granule 176 as possibly containing matching rows for our query."),(0,r.kt)("p",null,"ClickHouse now uses the selected mark number (176) from the index for a positional array lookup in the UserID.mrk mark file in order to get the two offsets for locating granule 176."),(0,r.kt)("p",null,"As shown, the first offset is locating the compressed file block within the UserID.bin data file that in turn contains the compressed version of granule 176."),(0,r.kt)("p",null,"Once the located file block is uncompressed into the main memory, the second offset from the mark file can be used to locate granule 176 within the uncompressed data."),(0,r.kt)("p",null,"ClickHouse needs to locate (and stream all values from) granule 176 from both the UserID.bin data file and the URL.bin data file in order to execute our example query (top 10 most clicked URLs for the internet user with the UserID 749.927.693)."),(0,r.kt)("p",null,"The diagram above shows how ClickHouse is locating the granule for the UserID.bin data file."),(0,r.kt)("p",null,"In parallel, ClickHouse is doing the same for granule 176 for the URL.bin data file. The two respective granules are aligned and streamed into the ClickHouse engine for further processing i.e. aggregating and counting the URL values per group for all rows where the UserID is 749.927.693, before finally outputting the 10 largest URL groups in descending count order."))}c.isMDXComponent=!0},45231:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sparse-primary-indexes-01-cc9409cc279f3a74cb498d158ef7c95e.png"},37705:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sparse-primary-indexes-02-f6b524b73c2747c0c26aaf8a8a06a89e.png"},72661:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sparse-primary-indexes-03a-3ce2298f3ae8d3577ad662796ed7de5c.png"},77695:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sparse-primary-indexes-03b-269cbb9a4febef2ad4e1e6a821fcbc11.png"},39e3:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sparse-primary-indexes-04-404eeaadb2a222c2a7fca9827bcfda4a.png"},94774:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sparse-primary-indexes-05-02e2356da8eb292a54513b2f587cfaf6.png"},20990:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sparse-primary-indexes-06-8c596fa6d0425def7d7389acc954a63e.png"}}]);