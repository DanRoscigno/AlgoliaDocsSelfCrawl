"use strict";(self.webpackChunkclickhouse_docs_2_3_0=self.webpackChunkclickhouse_docs_2_3_0||[]).push([[34633],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var m=r.createContext({}),o=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=o(e.components);return r.createElement(m.Provider,{value:n},e.children)},p="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,m=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=o(t),c=a,d=p["".concat(m,".").concat(c)]||p[c]||g[c]||i;return t?r.createElement(d,s(s({ref:n},u),{},{components:t})):r.createElement(d,s({ref:n},u))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=c;var l={};for(var m in n)hasOwnProperty.call(n,m)&&(l[m]=n[m]);l.originalType=e,l[p]="string"==typeof e?e:a,s[1]=l;for(var o=2;o<i;o++)s[o]=t[o];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},79748:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>s,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>o});var r=t(87462),a=(t(67294),t(3905));const i={slug:"/en/engines/table-engines/mergetree-family/summingmergetree",sidebar_position:50,sidebar_label:"SummingMergeTree"},s="SummingMergeTree",l={unversionedId:"en/engines/table-engines/mergetree-family/summingmergetree",id:"en/engines/table-engines/mergetree-family/summingmergetree",title:"SummingMergeTree",description:"The engine inherits from MergeTree. The difference is that when merging data parts for SummingMergeTree tables ClickHouse replaces all the rows with the same primary key (or more accurately, with the same sorting key) with one row which contains summarized values for the columns with the numeric data type. If the sorting key is composed in a way that a single key value corresponds to large number of rows, this significantly reduces storage volume and speeds up data selection.",source:"@site/docs/en/engines/table-engines/mergetree-family/summingmergetree.md",sourceDirName:"en/engines/table-engines/mergetree-family",slug:"/en/engines/table-engines/mergetree-family/summingmergetree",permalink:"/docs/en/engines/table-engines/mergetree-family/summingmergetree",draft:!1,editUrl:"https://github.com/ClickHouse/ClickHouse/tree/master/docs/en/engines/table-engines/mergetree-family/summingmergetree.md",tags:[],version:"current",sidebarPosition:50,frontMatter:{slug:"/en/engines/table-engines/mergetree-family/summingmergetree",sidebar_position:50,sidebar_label:"SummingMergeTree"},sidebar:"english",previous:{title:"ReplacingMergeTree",permalink:"/docs/en/engines/table-engines/mergetree-family/replacingmergetree"},next:{title:"AggregatingMergeTree",permalink:"/docs/en/engines/table-engines/mergetree-family/aggregatingmergetree"}},m={},o=[{value:"Creating a Table",id:"creating-a-table",level:2},{value:"Parameters of SummingMergeTree",id:"parameters-of-summingmergetree",level:3},{value:"columns",id:"columns",level:4},{value:"Query clauses",id:"query-clauses",level:3},{value:"Usage Example",id:"usage-example",level:2},{value:"Data Processing",id:"data-processing",level:2},{value:"Common Rules for Summation",id:"common-rules-for-summation",level:3},{value:"The Summation in the Aggregatefunction Columns",id:"the-summation-in-the-aggregatefunction-columns",level:3},{value:"Nested Structures",id:"nested-structures",level:3}],u={toc:o},p="wrapper";function g(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"summingmergetree"},"SummingMergeTree"),(0,a.kt)("p",null,"The engine inherits from ",(0,a.kt)("a",{parentName:"p",href:"/docs/en/engines/table-engines/mergetree-family/mergetree#table_engines-mergetree"},"MergeTree"),". The difference is that when merging data parts for ",(0,a.kt)("inlineCode",{parentName:"p"},"SummingMergeTree")," tables ClickHouse replaces all the rows with the same primary key (or more accurately, with the same ",(0,a.kt)("a",{parentName:"p",href:"/docs/en/engines/table-engines/mergetree-family/mergetree"},"sorting key"),") with one row which contains summarized values for the columns with the numeric data type. If the sorting key is composed in a way that a single key value corresponds to large number of rows, this significantly reduces storage volume and speeds up data selection."),(0,a.kt)("p",null,"We recommend using the engine together with ",(0,a.kt)("inlineCode",{parentName:"p"},"MergeTree"),". Store complete data in ",(0,a.kt)("inlineCode",{parentName:"p"},"MergeTree")," table, and use ",(0,a.kt)("inlineCode",{parentName:"p"},"SummingMergeTree")," for aggregated data storing, for example, when preparing reports. Such an approach will prevent you from losing valuable data due to an incorrectly composed primary key."),(0,a.kt)("h2",{id:"creating-a-table"},"Creating a Table"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]\n(\n    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],\n    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],\n    ...\n) ENGINE = SummingMergeTree([columns])\n[PARTITION BY expr]\n[ORDER BY expr]\n[SAMPLE BY expr]\n[SETTINGS name=value, ...]\n")),(0,a.kt)("p",null,"For a description of request parameters, see ",(0,a.kt)("a",{parentName:"p",href:"/docs/en/sql-reference/statements/create/table"},"request description"),"."),(0,a.kt)("h3",{id:"parameters-of-summingmergetree"},"Parameters of SummingMergeTree"),(0,a.kt)("h4",{id:"columns"},"columns"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"columns")," - a tuple with the names of columns where values will be summarized. Optional parameter.\nThe columns must be of a numeric type and must not be in the primary key."),(0,a.kt)("p",null," If ",(0,a.kt)("inlineCode",{parentName:"p"},"columns")," is not specified, ClickHouse summarizes the values in all columns with a numeric data type that are not in the primary key."),(0,a.kt)("h3",{id:"query-clauses"},"Query clauses"),(0,a.kt)("p",null,"When creating a ",(0,a.kt)("inlineCode",{parentName:"p"},"SummingMergeTree")," table the same ",(0,a.kt)("a",{parentName:"p",href:"/docs/en/engines/table-engines/mergetree-family/mergetree"},"clauses")," are required, as when creating a ",(0,a.kt)("inlineCode",{parentName:"p"},"MergeTree")," table."),(0,a.kt)("details",{markdown:"1"},(0,a.kt)("summary",null,"Deprecated Method for Creating a Table"),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"Do not use this method in new projects and, if possible, switch the old projects to the method described above.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]\n(\n    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],\n    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],\n    ...\n) ENGINE [=] SummingMergeTree(date-column [, sampling_expression], (primary, key), index_granularity, [columns])\n")),(0,a.kt)("p",null,"All of the parameters excepting ",(0,a.kt)("inlineCode",{parentName:"p"},"columns")," have the same meaning as in ",(0,a.kt)("inlineCode",{parentName:"p"},"MergeTree"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"columns")," \u2014 tuple with names of columns values of which will be summarized. Optional parameter. For a description, see the text above."))),(0,a.kt)("h2",{id:"usage-example"},"Usage Example"),(0,a.kt)("p",null,"Consider the following table:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE summtt\n(\n    key UInt32,\n    value UInt32\n)\nENGINE = SummingMergeTree()\nORDER BY key\n")),(0,a.kt)("p",null,"Insert data to it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO summtt Values(1,1),(1,2),(2,1)\n")),(0,a.kt)("p",null,"ClickHouse may sum all the rows not completely (",(0,a.kt)("a",{parentName:"p",href:"#data-processing"},"see below"),"), so we use an aggregate function ",(0,a.kt)("inlineCode",{parentName:"p"},"sum")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"GROUP BY")," clause in the query."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT key, sum(value) FROM summtt GROUP BY key\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500key\u2500\u252c\u2500sum(value)\u2500\u2510\n\u2502   2 \u2502          1 \u2502\n\u2502   1 \u2502          3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,a.kt)("h2",{id:"data-processing"},"Data Processing"),(0,a.kt)("p",null,"When data are inserted into a table, they are saved as-is. ClickHouse merges the inserted parts of data periodically and this is when rows with the same primary key are summed and replaced with one for each resulting part of data."),(0,a.kt)("p",null,"ClickHouse can merge the data parts so that different resulting parts of data can consist rows with the same primary key, i.e.\xa0the summation will be incomplete. Therefore (",(0,a.kt)("inlineCode",{parentName:"p"},"SELECT"),") an aggregate function ",(0,a.kt)("a",{parentName:"p",href:"/docs/en/sql-reference/aggregate-functions/reference/sum#agg_function-sum"},"sum()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"GROUP BY")," clause should be used in a query as described in the example above."),(0,a.kt)("h3",{id:"common-rules-for-summation"},"Common Rules for Summation"),(0,a.kt)("p",null,"The values in the columns with the numeric data type are summarized. The set of columns is defined by the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"columns"),"."),(0,a.kt)("p",null,"If the values were 0 in all of the columns for summation, the row is deleted."),(0,a.kt)("p",null,"If column is not in the primary key and is not summarized, an arbitrary value is selected from the existing ones."),(0,a.kt)("p",null,"The values are not summarized for columns in the primary key."),(0,a.kt)("h3",{id:"the-summation-in-the-aggregatefunction-columns"},"The Summation in the Aggregatefunction Columns"),(0,a.kt)("p",null,"For columns of ",(0,a.kt)("a",{parentName:"p",href:"/docs/en/sql-reference/data-types/aggregatefunction"},"AggregateFunction type")," ClickHouse behaves as ",(0,a.kt)("a",{parentName:"p",href:"/docs/en/engines/table-engines/mergetree-family/aggregatingmergetree"},"AggregatingMergeTree")," engine aggregating according to the function."),(0,a.kt)("h3",{id:"nested-structures"},"Nested Structures"),(0,a.kt)("p",null,"Table can have nested data structures that are processed in a special way."),(0,a.kt)("p",null,"If the name of a nested table ends with ",(0,a.kt)("inlineCode",{parentName:"p"},"Map")," and it contains at least two columns that meet the following criteria:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the first column is numeric ",(0,a.kt)("inlineCode",{parentName:"li"},"(*Int*, Date, DateTime)")," or a string ",(0,a.kt)("inlineCode",{parentName:"li"},"(String, FixedString)"),", let\u2019s call it ",(0,a.kt)("inlineCode",{parentName:"li"},"key"),","),(0,a.kt)("li",{parentName:"ul"},"the other columns are arithmetic ",(0,a.kt)("inlineCode",{parentName:"li"},"(*Int*, Float32/64)"),", let\u2019s call it ",(0,a.kt)("inlineCode",{parentName:"li"},"(values...)"),",")),(0,a.kt)("p",null,"then this nested table is interpreted as a mapping of ",(0,a.kt)("inlineCode",{parentName:"p"},"key => (values...)"),", and when merging its rows, the elements of two data sets are merged by ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," with a summation of the corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"(values...)"),"."),(0,a.kt)("p",null,"Examples:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"DROP TABLE IF EXISTS nested_sum;\nCREATE TABLE nested_sum\n(\n    date Date,\n    site UInt32,\n    hitsMap Nested(\n        browser String,\n        imps UInt32,\n        clicks UInt32\n    )\n) ENGINE = SummingMergeTree\nPRIMARY KEY (date, site);\n\nINSERT INTO nested_sum VALUES ('2020-01-01', 12, ['Firefox', 'Opera'], [10, 5], [2, 1]);\nINSERT INTO nested_sum VALUES ('2020-01-01', 12, ['Chrome', 'Firefox'], [20, 1], [1, 1]);\nINSERT INTO nested_sum VALUES ('2020-01-01', 12, ['IE'], [22], [0]);\nINSERT INTO nested_sum VALUES ('2020-01-01', 10, ['Chrome'], [4], [3]);\n\nOPTIMIZE TABLE nested_sum FINAL; -- emulate merge \n\nSELECT * FROM nested_sum;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u252c\u2500site\u2500\u252c\u2500hitsMap.browser\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500hitsMap.imps\u2500\u252c\u2500hitsMap.clicks\u2500\u2510\n\u2502 2020-01-01 \u2502   10 \u2502 ['Chrome']                        \u2502 [4]          \u2502 [3]            \u2502\n\u2502 2020-01-01 \u2502   12 \u2502 ['Chrome','Firefox','IE','Opera'] \u2502 [20,11,22,5] \u2502 [1,3,0,1]      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSELECT\n    site,\n    browser,\n    impressions,\n    clicks\nFROM\n(\n    SELECT\n        site,\n        sumMap(hitsMap.browser, hitsMap.imps, hitsMap.clicks) AS imps_map\n    FROM nested_sum\n    GROUP BY site\n)\nARRAY JOIN\n    imps_map.1 AS browser,\n    imps_map.2 AS impressions,\n    imps_map.3 AS clicks;\n\n\u250c\u2500site\u2500\u252c\u2500browser\u2500\u252c\u2500impressions\u2500\u252c\u2500clicks\u2500\u2510\n\u2502   12 \u2502 Chrome  \u2502          20 \u2502      1 \u2502\n\u2502   12 \u2502 Firefox \u2502          11 \u2502      3 \u2502\n\u2502   12 \u2502 IE      \u2502          22 \u2502      0 \u2502\n\u2502   12 \u2502 Opera   \u2502           5 \u2502      1 \u2502\n\u2502   10 \u2502 Chrome  \u2502           4 \u2502      3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,a.kt)("p",null,"When requesting data, use the ",(0,a.kt)("a",{parentName:"p",href:"/docs/en/sql-reference/aggregate-functions/reference/summap"},"sumMap(key, value)")," function for aggregation of ",(0,a.kt)("inlineCode",{parentName:"p"},"Map"),"."),(0,a.kt)("p",null,"For nested data structure, you do not need to specify its columns in the tuple of columns for summation."))}g.isMDXComponent=!0}}]);