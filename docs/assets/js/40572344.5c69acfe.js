"use strict";(self.webpackChunkclickhouse_docs_2_3_0=self.webpackChunkclickhouse_docs_2_3_0||[]).push([[90136],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>g});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=r.createContext({}),c=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=c(e.components);return r.createElement(o.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(t),u=a,g=m["".concat(o,".").concat(u)]||m[u]||p[u]||i;return t?r.createElement(g,l(l({ref:n},d),{},{components:t})):r.createElement(g,l({ref:n},d))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=u;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[m]="string"==typeof e?e:a,l[1]=s;for(var c=2;c<i;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},42434:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=t(87462),a=(t(67294),t(3905));const i={slug:"/en/engines/table-engines/mergetree-family/invertedindexes",sidebar_label:"Inverted Indexes",description:"Quickly find search terms in text.",keywords:["full-text search","text search","inverted","index","indices"]},l="Full-text Search using Inverted Indexes [experimental]",s={unversionedId:"en/engines/table-engines/mergetree-family/invertedindexes",id:"en/engines/table-engines/mergetree-family/invertedindexes",title:"Full-text Search using Inverted Indexes [experimental]",description:"Quickly find search terms in text.",source:"@site/docs/en/engines/table-engines/mergetree-family/invertedindexes.md",sourceDirName:"en/engines/table-engines/mergetree-family",slug:"/en/engines/table-engines/mergetree-family/invertedindexes",permalink:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/invertedindexes",draft:!1,editUrl:"https://github.com/ClickHouse/ClickHouse/tree/master/docs/en/engines/table-engines/mergetree-family/invertedindexes.md",tags:[],version:"current",frontMatter:{slug:"/en/engines/table-engines/mergetree-family/invertedindexes",sidebar_label:"Inverted Indexes",description:"Quickly find search terms in text.",keywords:["full-text search","text search","inverted","index","indices"]},sidebar:"english",previous:{title:"Approximate Nearest Neighbor Search Indexes [experimental]",permalink:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/annindexes"},next:{title:"Log Family",permalink:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/log-family/"}},o={},c=[{value:"Usage",id:"usage",level:2},{value:"Full-text search of the Hacker News dataset",id:"full-text-search-of-the-hacker-news-dataset",level:2}],d={toc:c},m="wrapper";function p(e){let{components:n,...t}=e;return(0,a.kt)(m,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"full-text-search-using-inverted-indexes-experimental"},"Full-text Search using Inverted Indexes ","[experimental]"),(0,a.kt)("p",null,"Inverted indexes are an experimental type of ",(0,a.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree/#available-types-of-indices"},"secondary indexes")," which provide fast text search\ncapabilities for ",(0,a.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/string"},"String")," or ",(0,a.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/fixedstring"},"FixedString"),'\ncolumns. The main idea of an inverted index is to store a mapping from "terms" to the rows which contain these terms. "Terms" are\ntokenized cells of the string column. For example, the string cell "I will be a little late" is by default tokenized into six terms "I", "will",\n"be", "a", "little" and "late". Another kind of tokenizer is n-grams. For example, the result of 3-gram tokenization will be 21 terms "I w",\n" wi", "wil", "ill", "ll ", "l b", " be" etc. The more fine-granular the input strings are tokenized, the bigger but also the more\nuseful the resulting inverted index will be.'),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"Inverted indexes are experimental and should not be used in production environments yet. They may change in the future in backward-incompatible\nways, for example with respect to their DDL/DQL syntax or performance/compression characteristics.")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,"To use inverted indexes, first enable them in the configuration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"SET allow_experimental_inverted_index = true;\n")),(0,a.kt)("p",null,"An inverted index can be defined on a string column using the following syntax"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE tab\n(\n    `key` UInt64,\n    `str` String,\n    INDEX inv_idx(str) TYPE inverted(0) GRANULARITY 1\n)\nENGINE = MergeTree\nORDER BY key\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"N")," specifies the tokenizer:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"inverted(0)")," (or shorter: ",(0,a.kt)("inlineCode",{parentName:"li"},"inverted()"),') set the tokenizer to "tokens", i.e. split strings along spaces,'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"inverted(N)")," with ",(0,a.kt)("inlineCode",{parentName:"li"},"N"),' between 2 and 8 sets the tokenizer to "ngrams(N)"')),(0,a.kt)("p",null,"Being a type of skipping index, inverted indexes can be dropped or added to a column after table creation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE tab DROP INDEX inv_idx;\nALTER TABLE tab ADD INDEX inv_idx(s) TYPE inverted(2);\n")),(0,a.kt)("p",null,"To use the index, no special functions or syntax are required. Typical string search predicates automatically leverage the index. As\nexamples, consider:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO tab(key, str) values (1, 'Hello World');\nSELECT * from tab WHERE str == 'Hello World';\nSELECT * from tab WHERE str IN ('Hello', 'World');\nSELECT * from tab WHERE str LIKE '%Hello%';\nSELECT * from tab WHERE multiSearchAny(str, ['Hello', 'World']);\nSELECT * from tab WHERE hasToken(str, 'Hello');\n")),(0,a.kt)("p",null,"The inverted index also works on columns of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Array(String)"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Array(FixedString)"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Map(String)")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Map(String)"),"."),(0,a.kt)("p",null,'Like for other secondary indices, each column part has its own inverted index. Furthermore, each inverted index is internally divided into\n"segments". The existence and size of the segments are generally transparent to users but the segment size determines the memory consumption\nduring index construction (e.g. when two parts are merged). Configuration parameter "max_digestion_size_per_segment" (default: 256 MB)\ncontrols the amount of data read consumed from the underlying column before a new segment is created. Incrementing the parameter raises the\nintermediate memory consumption for index construction but also improves lookup performance since fewer segments need to be checked on\naverage to evaluate a query.'),(0,a.kt)("h2",{id:"full-text-search-of-the-hacker-news-dataset"},"Full-text search of the Hacker News dataset"),(0,a.kt)("p",null,"Let's look at the performance improvements of inverted indexes on a large dataset with lots of text. We will use 28.7M rows of comments on the popular Hacker News website. Here is the table without an inverted index:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE hackernews (\n    id UInt64,\n    deleted UInt8,\n    type String,\n    author String,\n    timestamp DateTime,\n    comment String,\n    dead UInt8,\n    parent UInt64,\n    poll UInt64,\n    children Array(UInt32),\n    url String,\n    score UInt32,\n    title String,\n    parts Array(UInt32),\n    descendants UInt32\n)\nENGINE = MergeTree\nORDER BY (type, author);\n")),(0,a.kt)("p",null,"The 28.7M rows are in a Parquet file in S3 - let's insert them into the ",(0,a.kt)("inlineCode",{parentName:"p"},"hackernews")," table:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO hackernews\n    SELECT * FROM s3Cluster(\n        'default',\n        'https://datasets-documentation.s3.eu-west-3.amazonaws.com/hackernews/hacknernews.parquet',\n        'Parquet',\n        '\n    id UInt64,\n    deleted UInt8,\n    type String,\n    by String,\n    time DateTime,\n    text String,\n    dead UInt8,\n    parent UInt64,\n    poll UInt64,\n    kids Array(UInt32),\n    url String,\n    score UInt32,\n    title String,\n    parts Array(UInt32),\n    descendants UInt32');\n")),(0,a.kt)("p",null,"Consider the following simple search for the term ",(0,a.kt)("inlineCode",{parentName:"p"},"ClickHouse")," (and its varied upper and lower cases) in the ",(0,a.kt)("inlineCode",{parentName:"p"},"comment")," column:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT count()\nFROM hackernews\nWHERE hasToken(lower(comment), 'clickhouse');\n")),(0,a.kt)("p",null,"Notice it takes 3 seconds to execute the query:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-response"},"\u250c\u2500count()\u2500\u2510\n\u2502    1145 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n1 row in set. Elapsed: 3.001 sec. Processed 28.74 million rows, 9.75 GB (9.58 million rows/s., 3.25 GB/s.)\n")),(0,a.kt)("p",null,"We will use ",(0,a.kt)("inlineCode",{parentName:"p"},"ALTER TABLE")," and add an inverted index on the lowercase of the ",(0,a.kt)("inlineCode",{parentName:"p"},"comment")," column, then materialize it (which can take a while - wait for it to materialize):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE hackernews\n     ADD INDEX comment_lowercase(lower(comment)) TYPE inverted;\n\nALTER TABLE hackernews MATERIALIZE INDEX comment_lowercase;\n")),(0,a.kt)("p",null,"We run the same query..."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT count()\nFROM hackernews\nWHERE hasToken(lower(comment), 'clickhouse')\n")),(0,a.kt)("p",null,"...and notice the query executes 4x faster:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-response"},"\u250c\u2500count()\u2500\u2510\n\u2502    1145 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n1 row in set. Elapsed: 0.747 sec. Processed 4.49 million rows, 1.77 GB (6.01 million rows/s., 2.37 GB/s.)\n")),(0,a.kt)("p",null,"We can also search for one or all of multiple terms, i.e., disjunctions or conjunctions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"-- multiple OR'ed terms\nSELECT count(*)\nFROM hackernews\nWHERE multiSearchAny(lower(comment), ['oltp', 'olap']);\n\n-- multiple AND'ed terms\nSELECT count(*)\nFROM hackernews\nWHERE hasToken(lower(comment), 'avx') AND hasToken(lower(comment), 'sve');\n")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Unlike other secondary indices, inverted indexes (for now) map to row numbers (row ids) instead of granule ids. The reason for this design\nis performance. In practice, users often search for multiple terms at once. For example, filter predicate ",(0,a.kt)("inlineCode",{parentName:"p"},"WHERE s LIKE '%little%' OR s LIKE\n'%big%'"),' can be evaluated directly using an inverted index by forming the union of the row id lists for terms "little" and "big". This also\nmeans that the parameter ',(0,a.kt)("inlineCode",{parentName:"p"},"GRANULARITY")," supplied to index creation has no meaning (it may be removed from the syntax in the future).")))}p.isMDXComponent=!0}}]);