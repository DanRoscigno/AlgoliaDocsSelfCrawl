"use strict";(self.webpackChunkclickhouse_docs_2_3_0=self.webpackChunkclickhouse_docs_2_3_0||[]).push([[78122],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>g});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var c=n.createContext({}),s=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},p=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(r),f=i,g=d["".concat(c,".").concat(f)]||d[f]||u[f]||o;return r?n.createElement(g,a(a({ref:t},p),{},{components:r})):n.createElement(g,a({ref:t},p))}));function g(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=r.length,a=new Array(o);a[0]=f;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[d]="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=r[s];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},64167:(e,t,r)=>{r.d(t,{ZP:()=>l});var n=r(87462),i=(r(67294),r(3905));const o={toc:[]},a="wrapper";function l(e){let{components:t,...r}=e;return(0,i.kt)(a,(0,n.Z)({},o,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If you are using a dictionary with ClickHouse Cloud please use the DDL query option to create your dictionaries, and create your dictionary as user ",(0,i.kt)("inlineCode",{parentName:"p"},"default"),".\nAlso, verify the list of supported dictionary sources in the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/whats-new/cloud-compatibility"},"Cloud Compatibility guide"),".")))}l.isMDXComponent=!0},43077:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>f,frontMatter:()=>a,metadata:()=>c,toc:()=>p});var n=r(87462),i=(r(67294),r(3905)),o=r(64167);const a={slug:"/en/sql-reference/dictionaries/external-dictionaries/regexp-tree",sidebar_position:47,sidebar_label:"RegExp Tree Dictionary",title:"RegExp Tree Dictionary"},l=void 0,c={unversionedId:"en/sql-reference/dictionaries/external-dictionaries/regexp-tree",id:"en/sql-reference/dictionaries/external-dictionaries/regexp-tree",title:"RegExp Tree Dictionary",description:"Regexp Tree dictionary stores multiple trees of regular expressions with attributions. Users can retrieve strings in the dictionary. If a string matches the root of the regexp tree, we will collect the corresponding attributes of the matched root and continue to walk the children. If any of the children matches the string, we will collect attributes and rewrite the old ones if conflicts occur, then continue the traverse until we reach leaf nodes.",source:"@site/docs/en/sql-reference/dictionaries/external-dictionaries/regexp-tree.md",sourceDirName:"en/sql-reference/dictionaries/external-dictionaries",slug:"/en/sql-reference/dictionaries/external-dictionaries/regexp-tree",permalink:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/regexp-tree",draft:!1,editUrl:"https://github.com/ClickHouse/ClickHouse/tree/master/docs/en/sql-reference/dictionaries/external-dictionaries/regexp-tree.md",tags:[],version:"current",sidebarPosition:47,frontMatter:{slug:"/en/sql-reference/dictionaries/external-dictionaries/regexp-tree",sidebar_position:47,sidebar_label:"RegExp Tree Dictionary",title:"RegExp Tree Dictionary"},sidebar:"english",previous:{title:"Polygon Dictionaries With Grids",permalink:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-polygon"},next:{title:"Embedded Dictionaries",permalink:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/internal-dicts"}},s={},p=[],d={toc:p},u="wrapper";function f(e){let{components:t,...r}=e;return(0,i.kt)(u,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Regexp Tree dictionary stores multiple trees of regular expressions with attributions. Users can retrieve strings in the dictionary. If a string matches the root of the regexp tree, we will collect the corresponding attributes of the matched root and continue to walk the children. If any of the children matches the string, we will collect attributes and rewrite the old ones if conflicts occur, then continue the traverse until we reach leaf nodes."),(0,i.kt)("p",null,"Example of the ddl query for creating Regexp Tree dictionary:"),(0,i.kt)(o.ZP,{mdxType:"CloudDetails"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"create dictionary regexp_dict\n(\n    regexp String,\n    name String,\n    version String\n)\nPRIMARY KEY(regexp)\nSOURCE(YAMLRegExpTree(PATH '/var/lib/clickhouse/user_files/regexp_tree.yaml'))\nLAYOUT(regexp_tree)\n...\n")),(0,i.kt)("p",null,"We only allow ",(0,i.kt)("inlineCode",{parentName:"p"},"YAMLRegExpTree")," to work with regexp_tree dicitionary layout. If you want to use other sources, please set variable ",(0,i.kt)("inlineCode",{parentName:"p"},"regexp_dict_allow_other_sources")," true."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Source")),(0,i.kt)("p",null,"We introduce a type of source called ",(0,i.kt)("inlineCode",{parentName:"p"},"YAMLRegExpTree")," representing the structure of Regexp Tree dictionary. An Example of a valid yaml config is like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"- regexp: 'Linux/(\\d+[\\.\\d]*).+tlinux'\n  name: 'TencentOS'\n  version: '\\1'\n\n- regexp: '\\d+/tclwebkit(?:\\d+[\\.\\d]*)'\n  name: 'Andriod'\n  versions:\n    - regexp: '33/tclwebkit'\n      version: '13'\n    - regexp: '3[12]/tclwebkit'\n      version: '12'\n    - regexp: '30/tclwebkit'\n      version: '11'\n    - regexp: '29/tclwebkit'\n      version: '10'\n")),(0,i.kt)("p",null,"The key ",(0,i.kt)("inlineCode",{parentName:"p"},"regexp")," represents the regular expression of a tree node. The name of key is same as the dictionary key. The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," is user-defined attributions in the dicitionary. The ",(0,i.kt)("inlineCode",{parentName:"p"},"versions")," (which can be any name that not appear in attributions or the key) indicates the children nodes of this tree. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Back Reference")),(0,i.kt)("p",null,"The value of an attribution could contain a back reference which refers to a capture group of the matched regular expression. Reference number ranges from 1 to 9 and writes as ",(0,i.kt)("inlineCode",{parentName:"p"},"$1")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"\\1"),"."),(0,i.kt)("p",null,"During the query execution, the back reference in the value will be replaced by the matched capture group."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Query")),(0,i.kt)("p",null,"Due to the specialty of Regexp Tree dictionary, we only allow functions ",(0,i.kt)("inlineCode",{parentName:"p"},"dictGet"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dictGetOrDefault")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"dictGetOrNull")," work with it."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT dictGet('regexp_dict', ('name', 'version'), '31/tclwebkit1024');\n")),(0,i.kt)("p",null,"Result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\u250c\u2500dictGet('regexp_dict', ('name', 'version'), '31/tclwebkit1024')\u2500\u2510\n\u2502 ('Andriod','12')                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}f.isMDXComponent=!0}}]);