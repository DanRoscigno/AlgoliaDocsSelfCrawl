"use strict";(self.webpackChunkclickhouse_docs_2_3_0=self.webpackChunkclickhouse_docs_2_3_0||[]).push([[42544],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>d});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},u="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(t),c=r,d=u["".concat(p,".").concat(c)]||u[c]||g[c]||i;return t?a.createElement(d,o(o({ref:n},m),{},{components:t})):a.createElement(d,o({ref:n},m))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=c;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},39359:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var a=t(87462),r=(t(67294),t(3905));const i={slug:"/en/engines/table-engines/mergetree-family/graphitemergetree",sidebar_position:90,sidebar_label:"GraphiteMergeTree"},o="GraphiteMergeTree",l={unversionedId:"en/engines/table-engines/mergetree-family/graphitemergetree",id:"en/engines/table-engines/mergetree-family/graphitemergetree",title:"GraphiteMergeTree",description:"This engine is designed for thinning and aggregating/averaging (rollup) Graphite data. It may be helpful to developers who want to use ClickHouse as a data store for Graphite.",source:"@site/docs/en/engines/table-engines/mergetree-family/graphitemergetree.md",sourceDirName:"en/engines/table-engines/mergetree-family",slug:"/en/engines/table-engines/mergetree-family/graphitemergetree",permalink:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/graphitemergetree",draft:!1,editUrl:"https://github.com/ClickHouse/ClickHouse/tree/master/docs/en/engines/table-engines/mergetree-family/graphitemergetree.md",tags:[],version:"current",sidebarPosition:90,frontMatter:{slug:"/en/engines/table-engines/mergetree-family/graphitemergetree",sidebar_position:90,sidebar_label:"GraphiteMergeTree"},sidebar:"english",previous:{title:"VersionedCollapsingMergeTree",permalink:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/versionedcollapsingmergetree"},next:{title:"Approximate Nearest Neighbor Search Indexes [experimental]",permalink:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/annindexes"}},p={},s=[{value:"Creating a Table",id:"creating-table",level:2},{value:"Rollup Configuration",id:"rollup-configuration",level:2},{value:"Required Columns",id:"required-columns",level:3},{value:"path_column_name",id:"path_column_name",level:4},{value:"time_column_name",id:"time_column_name",level:4},{value:"value_column_name",id:"value_column_name",level:4},{value:"version_column_name",id:"version_column_name",level:4},{value:"Patterns",id:"patterns",level:3},{value:"Configuration Example without rules types",id:"configuration-example",level:3},{value:"Configuration Example with rules types",id:"configuration-typed-example",level:3}],m={toc:s},u="wrapper";function g(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"graphitemergetree"},"GraphiteMergeTree"),(0,r.kt)("p",null,"This engine is designed for thinning and aggregating/averaging (rollup) ",(0,r.kt)("a",{parentName:"p",href:"http://graphite.readthedocs.io/en/latest/index.html"},"Graphite")," data. It may be helpful to developers who want to use ClickHouse as a data store for Graphite."),(0,r.kt)("p",null,"You can use any ClickHouse table engine to store the Graphite data if you do not need rollup, but if you need a rollup use ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphiteMergeTree"),". The engine reduces the volume of storage and increases the efficiency of queries from Graphite."),(0,r.kt)("p",null,"The engine inherits properties from ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree"},"MergeTree"),"."),(0,r.kt)("h2",{id:"creating-table"},"Creating a Table"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]\n(\n    Path String,\n    Time DateTime,\n    Value Float64,\n    Version <Numeric_type>\n    ...\n) ENGINE = GraphiteMergeTree(config_section)\n[PARTITION BY expr]\n[ORDER BY expr]\n[SAMPLE BY expr]\n[SETTINGS name=value, ...]\n")),(0,r.kt)("p",null,"See a detailed description of the ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/statements/create/table#create-table-query"},"CREATE TABLE")," query."),(0,r.kt)("p",null,"A table for the Graphite data should have the following columns for the following data:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Metric name (Graphite sensor). Data type: ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Time of measuring the metric. Data type: ",(0,r.kt)("inlineCode",{parentName:"p"},"DateTime"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Value of the metric. Data type: ",(0,r.kt)("inlineCode",{parentName:"p"},"Float64"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Version of the metric. Data type: any numeric (ClickHouse saves the rows with the highest version or the last written if versions are the same. Other rows are deleted during the merge of data parts)."))),(0,r.kt)("p",null,"The names of these columns should be set in the rollup configuration."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"GraphiteMergeTree parameters")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"config_section")," \u2014 Name of the section in the configuration file, where are the rules of rollup set.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Query clauses")),(0,r.kt)("p",null,"When creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphiteMergeTree")," table, the same ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/engines/table-engines/mergetree-family/mergetree#table_engine-mergetree-creating-a-table"},"clauses")," are required, as when creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"MergeTree")," table."),(0,r.kt)("details",{markdown:"1"},(0,r.kt)("summary",null,"Deprecated Method for Creating a Table"),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Do not use this method in new projects and, if possible, switch old projects to the method described above.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]\n(\n    EventDate Date,\n    Path String,\n    Time DateTime,\n    Value Float64,\n    Version <Numeric_type>\n    ...\n) ENGINE [=] GraphiteMergeTree(date-column [, sampling_expression], (primary, key), index_granularity, config_section)\n")),(0,r.kt)("p",null,"All of the parameters excepting ",(0,r.kt)("inlineCode",{parentName:"p"},"config_section")," have the same meaning as in ",(0,r.kt)("inlineCode",{parentName:"p"},"MergeTree"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"config_section")," \u2014 Name of the section in the configuration file, where are the rules of rollup set."))),(0,r.kt)("h2",{id:"rollup-configuration"},"Rollup Configuration"),(0,r.kt)("p",null,"The settings for rollup are defined by the ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/operations/server-configuration-parameters/settings#server_configuration_parameters-graphite"},"graphite_rollup")," parameter in the server configuration. The name of the parameter could be any. You can create several configurations and use them for different tables."),(0,r.kt)("p",null,"Rollup configuration structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  required-columns\n  patterns\n")),(0,r.kt)("h3",{id:"required-columns"},"Required Columns"),(0,r.kt)("h4",{id:"path_column_name"},"path_column_name"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"path_column_name")," \u2014 The name of the column storing the metric name (Graphite sensor). Default value: ",(0,r.kt)("inlineCode",{parentName:"p"},"Path"),"."),(0,r.kt)("h4",{id:"time_column_name"},"time_column_name"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"time_column_name")," \u2014 The name of the column storing the time of measuring the metric. Default value: ",(0,r.kt)("inlineCode",{parentName:"p"},"Time"),"."),(0,r.kt)("h4",{id:"value_column_name"},"value_column_name"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"value_column_name")," \u2014 The name of the column storing the value of the metric at the time set in ",(0,r.kt)("inlineCode",{parentName:"p"},"time_column_name"),". Default value: ",(0,r.kt)("inlineCode",{parentName:"p"},"Value"),"."),(0,r.kt)("h4",{id:"version_column_name"},"version_column_name"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"version_column_name")," \u2014 The name of the column storing the version of the metric. Default value: ",(0,r.kt)("inlineCode",{parentName:"p"},"Timestamp"),"."),(0,r.kt)("h3",{id:"patterns"},"Patterns"),(0,r.kt)("p",null,"Structure of the ",(0,r.kt)("inlineCode",{parentName:"p"},"patterns")," section:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"pattern\n    rule_type\n    regexp\n    function\npattern\n    rule_type\n    regexp\n    age + precision\n    ...\npattern\n    rule_type\n    regexp\n    function\n    age + precision\n    ...\npattern\n    ...\ndefault\n    function\n    age + precision\n    ...\n")),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Patterns must be strictly ordered:"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"Patterns without ",(0,r.kt)("inlineCode",{parentName:"li"},"function")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"retention"),"."),(0,r.kt)("li",{parentName:"ol"},"Patterns with both ",(0,r.kt)("inlineCode",{parentName:"li"},"function")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"retention"),"."),(0,r.kt)("li",{parentName:"ol"},"Pattern ",(0,r.kt)("inlineCode",{parentName:"li"},"default"),"."))),(0,r.kt)("p",null,"When processing a row, ClickHouse checks the rules in the ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern")," sections. Each of ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern")," (including ",(0,r.kt)("inlineCode",{parentName:"p"},"default"),") sections can contain ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," parameter for aggregation, ",(0,r.kt)("inlineCode",{parentName:"p"},"retention")," parameters or both. If the metric name matches the ",(0,r.kt)("inlineCode",{parentName:"p"},"regexp"),", the rules from the ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern")," section (or sections) are applied; otherwise, the rules from the ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," section are used."),(0,r.kt)("p",null,"Fields for ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," sections:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rule_type")," - a rule's type. It's applied only to a particular metrics. The engine use it to separate plain and tagged metrics. Optional parameter. Default value: ",(0,r.kt)("inlineCode",{parentName:"li"},"all"),".\nIt's unnecessary when performance is not critical, or only one metrics type is used, e.g. plain metrics. By default only one type of rules set is created. Otherwise, if any of special types is defined, two different sets are created. One for plain metrics (root.branch.leaf) and one for tagged metrics (root.branch.leaf;tag1=value1).\nThe default rules are ended up in both sets.\nValid values:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"-   `all` (default) - a universal rule, used when `rule_type` is omitted.\n-   `plain` - a rule for plain metrics. The field `regexp` is processed as regular expression.\n-   `tagged` - a rule for tagged metrics (metrics are stored in DB in the format of `someName?tag1=value1&tag2=value2&tag3=value3`). Regular expression must be sorted by tags' names, first tag must be `__name__` if exists. The field `regexp` is processed as regular expression.\n-   `tag_list` - a rule for tagged matrics, a simple DSL for easier metric description in graphite format `someName;tag1=value1;tag2=value2`, `someName`, or `tag1=value1;tag2=value2`. The field `regexp` is translated into a `tagged` rule. The sorting by tags' names is unnecessary, ti will be done automatically. A tag's value (but not a name) can be set as a regular expression, e.g. `env=(dev|staging)`.\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"regexp")," \u2013 A pattern for the metric name (a regular or DSL)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"age")," \u2013 The minimum age of the data in seconds."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"precision"),"\u2013 How precisely to define the age of the data in seconds. Should be a divisor for 86400 (seconds in a day)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"function")," \u2013 The name of the aggregating function to apply to data whose age falls within the range ",(0,r.kt)("inlineCode",{parentName:"li"},"[age, age + precision]"),". Accepted functions: min / max / any / avg. The average is calculated imprecisely, like the average of the averages.")),(0,r.kt)("h3",{id:"configuration-example"},"Configuration Example without rules types"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},"<graphite_rollup>\n    <version_column_name>Version</version_column_name>\n    <pattern>\n        <regexp>click_cost</regexp>\n        <function>any</function>\n        <retention>\n            <age>0</age>\n            <precision>5</precision>\n        </retention>\n        <retention>\n            <age>86400</age>\n            <precision>60</precision>\n        </retention>\n    </pattern>\n    <default>\n        <function>max</function>\n        <retention>\n            <age>0</age>\n            <precision>60</precision>\n        </retention>\n        <retention>\n            <age>3600</age>\n            <precision>300</precision>\n        </retention>\n        <retention>\n            <age>86400</age>\n            <precision>3600</precision>\n        </retention>\n    </default>\n</graphite_rollup>\n")),(0,r.kt)("h3",{id:"configuration-typed-example"},"Configuration Example with rules types"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},"<graphite_rollup>\n    <version_column_name>Version</version_column_name>\n    <pattern>\n        <rule_type>plain</rule_type>\n        <regexp>click_cost</regexp>\n        <function>any</function>\n        <retention>\n            <age>0</age>\n            <precision>5</precision>\n        </retention>\n        <retention>\n            <age>86400</age>\n            <precision>60</precision>\n        </retention>\n    </pattern>\n    <pattern>\n        <rule_type>tagged</rule_type>\n        <regexp>^((.*)|.)min\\?</regexp>\n        <function>min</function>\n        <retention>\n            <age>0</age>\n            <precision>5</precision>\n        </retention>\n        <retention>\n            <age>86400</age>\n            <precision>60</precision>\n        </retention>\n    </pattern>\n    <pattern>\n        <rule_type>tagged</rule_type>\n        <regexp><![CDATA[^someName\\?(.*&)*tag1=value1(&|$)]]></regexp>\n        <function>min</function>\n        <retention>\n            <age>0</age>\n            <precision>5</precision>\n        </retention>\n        <retention>\n            <age>86400</age>\n            <precision>60</precision>\n        </retention>\n    </pattern>\n    <pattern>\n        <rule_type>tag_list</rule_type>\n        <regexp>someName;tag2=value2</regexp>\n        <retention>\n            <age>0</age>\n            <precision>5</precision>\n        </retention>\n        <retention>\n            <age>86400</age>\n            <precision>60</precision>\n        </retention>\n    </pattern>\n    <default>\n        <function>max</function>\n        <retention>\n            <age>0</age>\n            <precision>60</precision>\n        </retention>\n        <retention>\n            <age>3600</age>\n            <precision>300</precision>\n        </retention>\n        <retention>\n            <age>86400</age>\n            <precision>3600</precision>\n        </retention>\n    </default>\n</graphite_rollup>\n")),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Data rollup is performed during merges. Usually, for old partitions, merges are not started, so for rollup it is necessary to trigger an unscheduled merge using ",(0,r.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/statements/optimize"},"optimize"),". Or use additional tools, for example ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/innogames/graphite-ch-optimizer"},"graphite-ch-optimizer"),".")))}g.isMDXComponent=!0}}]);