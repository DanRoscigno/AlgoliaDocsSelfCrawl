"use strict";(self.webpackChunkclickhouse_docs_2_3_0=self.webpackChunkclickhouse_docs_2_3_0||[]).push([[75115],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),c=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(o.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(a),m=i,h=p["".concat(o,".").concat(m)]||p[m]||u[m]||r;return a?n.createElement(h,l(l({ref:t},d),{},{components:a})):n.createElement(h,l({ref:t},d))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[p]="string"==typeof e?e:i,l[1]=s;for(var c=2;c<r;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},64167:(e,t,a)=>{a.d(t,{ZP:()=>s});var n=a(87462),i=(a(67294),a(3905));const r={toc:[]},l="wrapper";function s(e){let{components:t,...a}=e;return(0,i.kt)(l,(0,n.Z)({},r,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If you are using a dictionary with ClickHouse Cloud please use the DDL query option to create your dictionaries, and create your dictionary as user ",(0,i.kt)("inlineCode",{parentName:"p"},"default"),".\nAlso, verify the list of supported dictionary sources in the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/whats-new/cloud-compatibility"},"Cloud Compatibility guide"),".")))}s.isMDXComponent=!0},62250:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var n=a(87462),i=(a(67294),a(3905)),r=a(64167);const l={slug:"/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout",sidebar_position:41,sidebar_label:"Storing Dictionaries in Memory"},s="Storing Dictionaries in Memory",o={unversionedId:"en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout",id:"en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout",title:"Storing Dictionaries in Memory",description:"There are a variety of ways to store dictionaries in memory.",source:"@site/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md",sourceDirName:"en/sql-reference/dictionaries/external-dictionaries",slug:"/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout",permalink:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout",draft:!1,editUrl:"https://github.com/ClickHouse/ClickHouse/tree/master/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md",tags:[],version:"current",sidebarPosition:41,frontMatter:{slug:"/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout",sidebar_position:41,sidebar_label:"Storing Dictionaries in Memory"},sidebar:"english",previous:{title:"Configuring a Dictionary",permalink:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict"},next:{title:"Dictionary Updates",permalink:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-lifetime"}},c={},d=[{value:"Ways to Store Dictionaries in Memory",id:"ways-to-store-dictionaries-in-memory",level:2},{value:"flat",id:"flat",level:3},{value:"hashed",id:"hashed",level:3},{value:"sparse_hashed",id:"sparse_hashed",level:3},{value:"complex_key_hashed",id:"complex_key_hashed",level:3},{value:"complex_key_sparse_hashed",id:"complex_key_sparse_hashed",level:3},{value:"hashed_array",id:"hashed_array",level:3},{value:"complex_key_hashed_array",id:"complex_key_hashed_array",level:3},{value:"range_hashed",id:"range_hashed",level:3},{value:"complex_key_range_hashed",id:"complex_key_range_hashed",level:3},{value:"cache",id:"cache",level:3},{value:"complex_key_cache",id:"complex_key_cache",level:3},{value:"ssd_cache",id:"ssd_cache",level:3},{value:"complex_key_ssd_cache",id:"complex_key_ssd_cache",level:3},{value:"direct",id:"direct",level:3},{value:"complex_key_direct",id:"complex_key_direct",level:3},{value:"ip_trie",id:"ip_trie",level:3},{value:"Related Content",id:"related-content",level:2}],p={toc:d},u="wrapper";function m(e){let{components:t,...a}=e;return(0,i.kt)(u,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"storing-dictionaries-in-memory"},"Storing Dictionaries in Memory"),(0,i.kt)("p",null,"There are a variety of ways to store dictionaries in memory."),(0,i.kt)("p",null,"We recommend ",(0,i.kt)("a",{parentName:"p",href:"#flat"},"flat"),", ",(0,i.kt)("a",{parentName:"p",href:"#dicts-external_dicts_dict_layout-hashed"},"hashed")," and ",(0,i.kt)("a",{parentName:"p",href:"#complex-key-hashed"},"complex_key_hashed"),", which provide optimal processing speed."),(0,i.kt)("p",null,"Caching is not recommended because of potentially poor performance and difficulties in selecting optimal parameters. Read more in the section ",(0,i.kt)("a",{parentName:"p",href:"#cache"},"cache"),"."),(0,i.kt)("p",null,"There are several ways to improve dictionary performance:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Call the function for working with the dictionary after ",(0,i.kt)("inlineCode",{parentName:"li"},"GROUP BY"),"."),(0,i.kt)("li",{parentName:"ul"},"Mark attributes to extract as injective. An attribute is called injective if different attribute values correspond to different keys. So when ",(0,i.kt)("inlineCode",{parentName:"li"},"GROUP BY")," uses a function that fetches an attribute value by the key, this function is automatically taken out of ",(0,i.kt)("inlineCode",{parentName:"li"},"GROUP BY"),".")),(0,i.kt)("p",null,"ClickHouse generates an exception for errors with dictionaries. Examples of errors:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The dictionary being accessed could not be loaded."),(0,i.kt)("li",{parentName:"ul"},"Error querying a ",(0,i.kt)("inlineCode",{parentName:"li"},"cached")," dictionary.")),(0,i.kt)("p",null,"You can view the list of dictionaries and their statuses in the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/operations/system-tables/dictionaries"},"system.dictionaries")," table."),(0,i.kt)(r.ZP,{mdxType:"CloudDetails"}),(0,i.kt)("p",null,"The configuration looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<clickhouse>\n    <dictionary>\n        ...\n        <layout>\n            <layout_type>\n                \x3c!-- layout settings --\x3e\n            </layout_type>\n        </layout>\n        ...\n    </dictionary>\n</clickhouse>\n")),(0,i.kt)("p",null,"Corresponding ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/statements/create/dictionary"},"DDL-query"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE DICTIONARY (...)\n...\nLAYOUT(LAYOUT_TYPE(param value)) -- layout settings\n...\n")),(0,i.kt)("p",null,"Dictionaries without word ",(0,i.kt)("inlineCode",{parentName:"p"},"complex-key*")," in a layout have a key with ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type, ",(0,i.kt)("inlineCode",{parentName:"p"},"complex-key*")," dictionaries have a composite key (complex, with arbitrary types)."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," keys in XML dictionaries are defined with ",(0,i.kt)("inlineCode",{parentName:"p"},"<id>")," tag."),(0,i.kt)("p",null,"Configuration example (column key_column has UInt64 type):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"...\n<structure>\n    <id>\n        <name>key_column</name>\n    </id>\n...\n")),(0,i.kt)("p",null,"Composite ",(0,i.kt)("inlineCode",{parentName:"p"},"complex")," keys XML dictionaries are defined ",(0,i.kt)("inlineCode",{parentName:"p"},"<key>")," tag."),(0,i.kt)("p",null,"Configuration example of a composite key (key has one element with ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/string"},"String")," type):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"...\n<structure>\n    <key>\n        <attribute>\n            <name>country_code</name>\n            <type>String</type>\n        </attribute>\n    </key>\n...\n")),(0,i.kt)("h2",{id:"ways-to-store-dictionaries-in-memory"},"Ways to Store Dictionaries in Memory"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#flat"},"flat")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dicts-external_dicts_dict_layout-hashed"},"hashed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dicts-external_dicts_dict_layout-sparse_hashed"},"sparse_hashed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#complex-key-hashed"},"complex_key_hashed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#complex-key-sparse-hashed"},"complex_key_sparse_hashed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dicts-external_dicts_dict_layout-hashed-array"},"hashed_array")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#complex-key-hashed-array"},"complex_key_hashed_array")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#range-hashed"},"range_hashed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#complex-key-range-hashed"},"complex_key_range_hashed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#cache"},"cache")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#complex-key-cache"},"complex_key_cache")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#ssd-cache"},"ssd_cache")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#complex-key-ssd-cache"},"complex_key_ssd_cache")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#direct"},"direct")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#complex-key-direct"},"complex_key_direct")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#ip-trie"},"ip_trie"))),(0,i.kt)("h3",{id:"flat"},"flat"),(0,i.kt)("p",null,"The dictionary is completely stored in memory in the form of flat arrays. How much memory does the dictionary use? The amount is proportional to the size of the largest key (in space used)."),(0,i.kt)("p",null,"The dictionary key has the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type and the value is limited to ",(0,i.kt)("inlineCode",{parentName:"p"},"max_array_size")," (by default \u2014 500,000). If a larger key is discovered when creating the dictionary, ClickHouse throws an exception and does not create the dictionary. Dictionary flat arrays initial size is controlled by ",(0,i.kt)("inlineCode",{parentName:"p"},"initial_array_size")," setting (by default \u2014 1024)."),(0,i.kt)("p",null,"All types of sources are supported. When updating, data (from a file or from a table) is read in it entirety."),(0,i.kt)("p",null,"This method provides the best performance among all available methods of storing the dictionary."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <flat>\n    <initial_array_size>50000</initial_array_size>\n    <max_array_size>5000000</max_array_size>\n  </flat>\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(FLAT(INITIAL_ARRAY_SIZE 50000 MAX_ARRAY_SIZE 5000000))\n")),(0,i.kt)("h3",{id:"hashed"},"hashed"),(0,i.kt)("p",null,"The dictionary is completely stored in memory in the form of a hash table. The dictionary can contain any number of elements with any identifiers In practice, the number of keys can reach tens of millions of items."),(0,i.kt)("p",null,"The dictionary key has the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type."),(0,i.kt)("p",null,"All types of sources are supported. When updating, data (from a file or from a table) is read in its entirety."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <hashed />\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(HASHED())\n")),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"shards")," greater then 1 (default is ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") the dictionary will load data in parallel, useful if you have huge amount of elements in one dictionary."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <hashed>\n    <shards>10</shards>\n    \x3c!-- Size of the backlog for blocks in parallel queue.\n\n         Since the bottleneck in parallel loading is rehash, and so to avoid\n         stalling because of thread is doing rehash, you need to have some\n         backlog.\n\n         10000 is good balance between memory and speed.\n         Even for 10e10 elements and can handle all the load without starvation. --\x3e\n    <shard_load_queue_backlog>10000</shard_load_queue_backlog>\n  </hashed>\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(HASHED(SHARDS 10 [SHARD_LOAD_QUEUE_BACKLOG 10000]))\n")),(0,i.kt)("h3",{id:"sparse_hashed"},"sparse_hashed"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"hashed"),", but uses less memory in favor more CPU usage."),(0,i.kt)("p",null,"The dictionary key has the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <sparse_hashed />\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(SPARSE_HASHED())\n")),(0,i.kt)("p",null,"It is also possible to use ",(0,i.kt)("inlineCode",{parentName:"p"},"shards")," for this type of dictionary, and again it is more important for ",(0,i.kt)("inlineCode",{parentName:"p"},"sparse_hashed")," then for ",(0,i.kt)("inlineCode",{parentName:"p"},"hashed"),", since ",(0,i.kt)("inlineCode",{parentName:"p"},"sparse_hashed")," is slower."),(0,i.kt)("h3",{id:"complex_key_hashed"},"complex_key_hashed"),(0,i.kt)("p",null,"This type of storage is for use with composite ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure"},"keys"),". Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"hashed"),"."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <complex_key_hashed>\n    <shards>1</shards>\n    \x3c!-- <shard_load_queue_backlog>10000</shard_load_queue_backlog> --\x3e\n  </complex_key_hashed>\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(COMPLEX_KEY_HASHED([SHARDS 1] [SHARD_LOAD_QUEUE_BACKLOG 10000]))\n")),(0,i.kt)("h3",{id:"complex_key_sparse_hashed"},"complex_key_sparse_hashed"),(0,i.kt)("p",null,"This type of storage is for use with composite ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure"},"keys"),". Similar to ",(0,i.kt)("a",{parentName:"p",href:"#dicts-external_dicts_dict_layout-sparse_hashed"},"sparse_hashed"),"."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <complex_key_sparse_hashed>\n    <shards>1</shards>\n  </complex_key_sparse_hashed>\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(COMPLEX_KEY_SPARSE_HASHED([SHARDS 1] [SHARD_LOAD_QUEUE_BACKLOG 10000]))\n")),(0,i.kt)("h3",{id:"hashed_array"},"hashed_array"),(0,i.kt)("p",null,"The dictionary is completely stored in memory. Each attribute is stored in an array. The key attribute is stored in the form of a hashed table where value is an index in the attributes array. The dictionary can contain any number of elements with any identifiers. In practice, the number of keys can reach tens of millions of items."),(0,i.kt)("p",null,"The dictionary key has the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type."),(0,i.kt)("p",null,"All types of sources are supported. When updating, data (from a file or from a table) is read in its entirety."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <hashed_array>\n  </hashed_array>\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(HASHED_ARRAY())\n")),(0,i.kt)("h3",{id:"complex_key_hashed_array"},"complex_key_hashed_array"),(0,i.kt)("p",null,"This type of storage is for use with composite ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure"},"keys"),". Similar to ",(0,i.kt)("a",{parentName:"p",href:"#dicts-external_dicts_dict_layout-hashed-array"},"hashed_array"),"."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <complex_key_hashed_array />\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(COMPLEX_KEY_HASHED_ARRAY())\n")),(0,i.kt)("h3",{id:"range_hashed"},"range_hashed"),(0,i.kt)("p",null,"The dictionary is stored in memory in the form of a hash table with an ordered array of ranges and their corresponding values."),(0,i.kt)("p",null,"The dictionary key has the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type.\nThis storage method works the same way as hashed and allows using date/time (arbitrary numeric type) ranges in addition to the key."),(0,i.kt)("p",null,"Example: The table contains discounts for each advertiser in the format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500advertiser_id\u2500\u252c\u2500discount_start_date\u2500\u252c\u2500discount_end_date\u2500\u252c\u2500amount\u2500\u2510\n\u2502           123 \u2502          2015-01-16 \u2502        2015-01-31 \u2502   0.25 \u2502\n\u2502           123 \u2502          2015-01-01 \u2502        2015-01-15 \u2502   0.15 \u2502\n\u2502           456 \u2502          2015-01-01 \u2502        2015-01-15 \u2502   0.05 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,i.kt)("p",null,"To use a sample for date ranges, define the ",(0,i.kt)("inlineCode",{parentName:"p"},"range_min")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"range_max")," elements in the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure"},"structure"),". These elements must contain elements ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," (if ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," is not specified, the default type will be used - Date). ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," can be any numeric type (Date / DateTime / UInt64 / Int32 / others)."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Values of ",(0,i.kt)("inlineCode",{parentName:"p"},"range_min")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"range_max")," should fit in ",(0,i.kt)("inlineCode",{parentName:"p"},"Int64")," type.")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n    <range_hashed>\n        \x3c!-- Strategy for overlapping ranges (min/max). Default: min (return a matching range with the min(range_min -> range_max) value) --\x3e\n        <range_lookup_strategy>min</range_lookup_strategy>\n    </range_hashed>\n</layout>\n<structure>\n    <id>\n        <name>advertiser_id</name>\n    </id>\n    <range_min>\n        <name>discount_start_date</name>\n        <type>Date</type>\n    </range_min>\n    <range_max>\n        <name>discount_end_date</name>\n        <type>Date</type>\n    </range_max>\n    ...\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE DICTIONARY discounts_dict (\n    advertiser_id UInt64,\n    discount_start_date Date,\n    discount_end_date Date,\n    amount Float64\n)\nPRIMARY KEY id\nSOURCE(CLICKHOUSE(TABLE 'discounts'))\nLIFETIME(MIN 1 MAX 1000)\nLAYOUT(RANGE_HASHED(range_lookup_strategy 'max'))\nRANGE(MIN discount_start_date MAX discount_end_date)\n")),(0,i.kt)("p",null,"To work with these dictionaries, you need to pass an additional argument to the ",(0,i.kt)("inlineCode",{parentName:"p"},"dictGet")," function, for which a range is selected:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"dictGet('dict_name', 'attr_name', id, date)\n")),(0,i.kt)("p",null,"Query example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT dictGet('discounts_dict', 'amount', 1, '2022-10-20'::Date);\n")),(0,i.kt)("p",null,"This function returns the value for the specified ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),"s and the date range that includes the passed date."),(0,i.kt)("p",null,"Details of the algorithm:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," is not found or a range is not found for the ",(0,i.kt)("inlineCode",{parentName:"li"},"id"),", it returns the default value of the attribute's type."),(0,i.kt)("li",{parentName:"ul"},"If there are overlapping ranges and ",(0,i.kt)("inlineCode",{parentName:"li"},"range_lookup_strategy=min"),", it returns a matching range with minimal ",(0,i.kt)("inlineCode",{parentName:"li"},"range_min"),", if several ranges found, it returns a range with minimal ",(0,i.kt)("inlineCode",{parentName:"li"},"range_max"),", if again several ranges found (several ranges had the same ",(0,i.kt)("inlineCode",{parentName:"li"},"range_min")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"range_max")," it returns a random range of them."),(0,i.kt)("li",{parentName:"ul"},"If there are overlapping ranges and ",(0,i.kt)("inlineCode",{parentName:"li"},"range_lookup_strategy=max"),", it returns a matching range with maximal ",(0,i.kt)("inlineCode",{parentName:"li"},"range_min"),", if several ranges found, it returns a range with maximal ",(0,i.kt)("inlineCode",{parentName:"li"},"range_max"),", if again several ranges found (several ranges had the same ",(0,i.kt)("inlineCode",{parentName:"li"},"range_min")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"range_max")," it returns a random range of them."),(0,i.kt)("li",{parentName:"ul"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"range_max")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"NULL"),", the range is open. ",(0,i.kt)("inlineCode",{parentName:"li"},"NULL")," is treated as maximal possible value. For the ",(0,i.kt)("inlineCode",{parentName:"li"},"range_min")," ",(0,i.kt)("inlineCode",{parentName:"li"},"1970-01-01")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," (-MAX_INT) can be used as the open value.")),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<clickhouse>\n    <dictionary>\n        ...\n\n        <layout>\n            <range_hashed />\n        </layout>\n\n        <structure>\n            <id>\n                <name>Abcdef</name>\n            </id>\n            <range_min>\n                <name>StartTimeStamp</name>\n                <type>UInt64</type>\n            </range_min>\n            <range_max>\n                <name>EndTimeStamp</name>\n                <type>UInt64</type>\n            </range_max>\n            <attribute>\n                <name>XXXType</name>\n                <type>String</type>\n                <null_value />\n            </attribute>\n        </structure>\n\n    </dictionary>\n</clickhouse>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE DICTIONARY somedict(\n    Abcdef UInt64,\n    StartTimeStamp UInt64,\n    EndTimeStamp UInt64,\n    XXXType String DEFAULT ''\n)\nPRIMARY KEY Abcdef\nRANGE(MIN StartTimeStamp MAX EndTimeStamp)\n")),(0,i.kt)("p",null,"Configuration example with overlapping ranges and open ranges:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE discounts\n(\n    advertiser_id UInt64,\n    discount_start_date Date,\n    discount_end_date Nullable(Date),\n    amount Float64\n)\nENGINE = Memory;\n\nINSERT INTO discounts VALUES (1, '2015-01-01', Null, 0.1);\nINSERT INTO discounts VALUES (1, '2015-01-15', Null, 0.2);\nINSERT INTO discounts VALUES (2, '2015-01-01', '2015-01-15', 0.3);\nINSERT INTO discounts VALUES (2, '2015-01-04', '2015-01-10', 0.4);\nINSERT INTO discounts VALUES (3, '1970-01-01', '2015-01-15', 0.5);\nINSERT INTO discounts VALUES (3, '1970-01-01', '2015-01-10', 0.6);\n\nSELECT * FROM discounts ORDER BY advertiser_id, discount_start_date;\n\u250c\u2500advertiser_id\u2500\u252c\u2500discount_start_date\u2500\u252c\u2500discount_end_date\u2500\u252c\u2500amount\u2500\u2510\n\u2502             1 \u2502          2015-01-01 \u2502              \u1d3a\u1d41\u1d38\u1d38 \u2502    0.1 \u2502\n\u2502             1 \u2502          2015-01-15 \u2502              \u1d3a\u1d41\u1d38\u1d38 \u2502    0.2 \u2502\n\u2502             2 \u2502          2015-01-01 \u2502        2015-01-15 \u2502    0.3 \u2502\n\u2502             2 \u2502          2015-01-04 \u2502        2015-01-10 \u2502    0.4 \u2502\n\u2502             3 \u2502          1970-01-01 \u2502        2015-01-15 \u2502    0.5 \u2502\n\u2502             3 \u2502          1970-01-01 \u2502        2015-01-10 \u2502    0.6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n-- RANGE_LOOKUP_STRATEGY 'max'\n\nCREATE DICTIONARY discounts_dict\n(\n    advertiser_id UInt64,\n    discount_start_date Date,\n    discount_end_date Nullable(Date),\n    amount Float64\n)\nPRIMARY KEY advertiser_id\nSOURCE(CLICKHOUSE(TABLE discounts))\nLIFETIME(MIN 600 MAX 900)\nLAYOUT(RANGE_HASHED(RANGE_LOOKUP_STRATEGY 'max'))\nRANGE(MIN discount_start_date MAX discount_end_date);\n\nselect dictGet('discounts_dict', 'amount', 1, toDate('2015-01-14')) res;\n\u250c\u2500res\u2500\u2510\n\u2502 0.1 \u2502 -- the only one range is matching: 2015-01-01 - Null\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nselect dictGet('discounts_dict', 'amount', 1, toDate('2015-01-16')) res;\n\u250c\u2500res\u2500\u2510\n\u2502 0.2 \u2502 -- two ranges are matching, range_min 2015-01-15 (0.2) is bigger than 2015-01-01 (0.1)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nselect dictGet('discounts_dict', 'amount', 2, toDate('2015-01-06')) res;\n\u250c\u2500res\u2500\u2510\n\u2502 0.4 \u2502 -- two ranges are matching, range_min 2015-01-04 (0.4) is bigger than 2015-01-01 (0.3)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nselect dictGet('discounts_dict', 'amount', 3, toDate('2015-01-01')) res;\n\u250c\u2500res\u2500\u2510\n\u2502 0.5 \u2502 -- two ranges are matching, range_min are equal, 2015-01-15 (0.5) is bigger than 2015-01-10 (0.6)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nDROP DICTIONARY discounts_dict;\n\n-- RANGE_LOOKUP_STRATEGY 'min'\n\nCREATE DICTIONARY discounts_dict\n(\n    advertiser_id UInt64,\n    discount_start_date Date,\n    discount_end_date Nullable(Date),\n    amount Float64\n)\nPRIMARY KEY advertiser_id\nSOURCE(CLICKHOUSE(TABLE discounts))\nLIFETIME(MIN 600 MAX 900)\nLAYOUT(RANGE_HASHED(RANGE_LOOKUP_STRATEGY 'min'))\nRANGE(MIN discount_start_date MAX discount_end_date);\n\nselect dictGet('discounts_dict', 'amount', 1, toDate('2015-01-14')) res;\n\u250c\u2500res\u2500\u2510\n\u2502 0.1 \u2502 -- the only one range is matching: 2015-01-01 - Null\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nselect dictGet('discounts_dict', 'amount', 1, toDate('2015-01-16')) res;\n\u250c\u2500res\u2500\u2510\n\u2502 0.1 \u2502 -- two ranges are matching, range_min 2015-01-01 (0.1) is less than 2015-01-15 (0.2)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nselect dictGet('discounts_dict', 'amount', 2, toDate('2015-01-06')) res;\n\u250c\u2500res\u2500\u2510\n\u2502 0.3 \u2502 -- two ranges are matching, range_min 2015-01-01 (0.3) is less than 2015-01-04 (0.4)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nselect dictGet('discounts_dict', 'amount', 3, toDate('2015-01-01')) res;\n\u250c\u2500res\u2500\u2510\n\u2502 0.6 \u2502 -- two ranges are matching, range_min are equal, 2015-01-10 (0.6) is less than 2015-01-15 (0.5)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,i.kt)("h3",{id:"complex_key_range_hashed"},"complex_key_range_hashed"),(0,i.kt)("p",null,"The dictionary is stored in memory in the form of a hash table with an ordered array of ranges and their corresponding values (see ",(0,i.kt)("a",{parentName:"p",href:"#range-hashed"},"range_hashed"),"). This type of storage is for use with composite ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure"},"keys"),"."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE DICTIONARY range_dictionary\n(\n  CountryID UInt64,\n  CountryKey String,\n  StartDate Date,\n  EndDate Date,\n  Tax Float64 DEFAULT 0.2\n)\nPRIMARY KEY CountryID, CountryKey\nSOURCE(CLICKHOUSE(TABLE 'date_table'))\nLIFETIME(MIN 1 MAX 1000)\nLAYOUT(COMPLEX_KEY_RANGE_HASHED())\nRANGE(MIN StartDate MAX EndDate);\n")),(0,i.kt)("h3",{id:"cache"},"cache"),(0,i.kt)("p",null,"The dictionary is stored in a cache that has a fixed number of cells. These cells contain frequently used elements."),(0,i.kt)("p",null,"The dictionary key has the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type."),(0,i.kt)("p",null,"When searching for a dictionary, the cache is searched first. For each block of data, all keys that are not found in the cache or are outdated are requested from the source using ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT attrs... FROM db.table WHERE id IN (k1, k2, ...)"),". The received data is then written to the cache."),(0,i.kt)("p",null,"If keys are not found in dictionary, then update cache task is created and added into update queue. Update queue properties can be controlled with settings ",(0,i.kt)("inlineCode",{parentName:"p"},"max_update_queue_size"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"update_queue_push_timeout_milliseconds"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"query_wait_timeout_milliseconds"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"max_threads_for_updates"),"."),(0,i.kt)("p",null,"For cache dictionaries, the expiration ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-lifetime"},"lifetime")," of data in the cache can be set. If more time than ",(0,i.kt)("inlineCode",{parentName:"p"},"lifetime")," has passed since loading the data in a cell, the cell\u2019s value is not used and key becomes expired. The key is re-requested the next time it needs to be used. This behaviour can be configured with setting ",(0,i.kt)("inlineCode",{parentName:"p"},"allow_read_expired_keys"),"."),(0,i.kt)("p",null,"This is the least effective of all the ways to store dictionaries. The speed of the cache depends strongly on correct settings and the usage scenario. A cache type dictionary performs well only when the hit rates are high enough (recommended 99% and higher). You can view the average hit rate in the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/operations/system-tables/dictionaries"},"system.dictionaries")," table."),(0,i.kt)("p",null,"If setting ",(0,i.kt)("inlineCode",{parentName:"p"},"allow_read_expired_keys")," is set to 1, by default 0. Then dictionary can support asynchronous updates. If a client requests keys and all of them are in cache, but some of them are expired, then dictionary will return expired keys for a client and request them asynchronously from the source."),(0,i.kt)("p",null,"To improve cache performance, use a subquery with ",(0,i.kt)("inlineCode",{parentName:"p"},"LIMIT"),", and call the function with the dictionary externally."),(0,i.kt)("p",null,"All types of sources are supported."),(0,i.kt)("p",null,"Example of settings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n    <cache>\n        \x3c!-- The size of the cache, in number of cells. Rounded up to a power of two. --\x3e\n        <size_in_cells>1000000000</size_in_cells>\n        \x3c!-- Allows to read expired keys. --\x3e\n        <allow_read_expired_keys>0</allow_read_expired_keys>\n        \x3c!-- Max size of update queue. --\x3e\n        <max_update_queue_size>100000</max_update_queue_size>\n        \x3c!-- Max timeout in milliseconds for push update task into queue. --\x3e\n        <update_queue_push_timeout_milliseconds>10</update_queue_push_timeout_milliseconds>\n        \x3c!-- Max wait timeout in milliseconds for update task to complete. --\x3e\n        <query_wait_timeout_milliseconds>60000</query_wait_timeout_milliseconds>\n        \x3c!-- Max threads for cache dictionary update. --\x3e\n        <max_threads_for_updates>4</max_threads_for_updates>\n    </cache>\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(CACHE(SIZE_IN_CELLS 1000000000))\n")),(0,i.kt)("p",null,"Set a large enough cache size. You need to experiment to select the number of cells:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Set some value."),(0,i.kt)("li",{parentName:"ol"},"Run queries until the cache is completely full."),(0,i.kt)("li",{parentName:"ol"},"Assess memory consumption using the ",(0,i.kt)("inlineCode",{parentName:"li"},"system.dictionaries")," table."),(0,i.kt)("li",{parentName:"ol"},"Increase or decrease the number of cells until the required memory consumption is reached.")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Do not use ClickHouse as a source, because it is slow to process queries with random reads.")),(0,i.kt)("h3",{id:"complex_key_cache"},"complex_key_cache"),(0,i.kt)("p",null,"This type of storage is for use with composite ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure"},"keys"),". Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"cache"),"."),(0,i.kt)("h3",{id:"ssd_cache"},"ssd_cache"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"cache"),", but stores data on SSD and index in RAM. All cache dictionary settings related to update queue can also be applied to SSD cache dictionaries."),(0,i.kt)("p",null,"The dictionary key has the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n    <ssd_cache>\n        \x3c!-- Size of elementary read block in bytes. Recommended to be equal to SSD's page size. --\x3e\n        <block_size>4096</block_size>\n        \x3c!-- Max cache file size in bytes. --\x3e\n        <file_size>16777216</file_size>\n        \x3c!-- Size of RAM buffer in bytes for reading elements from SSD. --\x3e\n        <read_buffer_size>131072</read_buffer_size>\n        \x3c!-- Size of RAM buffer in bytes for aggregating elements before flushing to SSD. --\x3e\n        <write_buffer_size>1048576</write_buffer_size>\n        \x3c!-- Path where cache file will be stored. --\x3e\n        <path>/var/lib/clickhouse/user_files/test_dict</path>\n    </ssd_cache>\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(SSD_CACHE(BLOCK_SIZE 4096 FILE_SIZE 16777216 READ_BUFFER_SIZE 1048576\n    PATH '/var/lib/clickhouse/user_files/test_dict'))\n")),(0,i.kt)("h3",{id:"complex_key_ssd_cache"},"complex_key_ssd_cache"),(0,i.kt)("p",null,"This type of storage is for use with composite ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure"},"keys"),". Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"ssd_cache"),"."),(0,i.kt)("h3",{id:"direct"},"direct"),(0,i.kt)("p",null,"The dictionary is not stored in memory and directly goes to the source during the processing of a request."),(0,i.kt)("p",null,"The dictionary key has the ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/data-types/int-uint"},"UInt64")," type."),(0,i.kt)("p",null,"All types of ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-sources"},"sources"),", except local files, are supported."),(0,i.kt)("p",null,"Configuration example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<layout>\n  <direct />\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LAYOUT(DIRECT())\n")),(0,i.kt)("h3",{id:"complex_key_direct"},"complex_key_direct"),(0,i.kt)("p",null,"This type of storage is for use with composite ",(0,i.kt)("a",{parentName:"p",href:"/AlgoliaDocsSelfCrawl/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure"},"keys"),". Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"direct"),"."),(0,i.kt)("h3",{id:"ip_trie"},"ip_trie"),(0,i.kt)("p",null,"This type of storage is for mapping network prefixes (IP addresses) to metadata such as ASN."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")),(0,i.kt)("p",null,"Suppose we have a table in ClickHouse that contains our IP prefixes and mappings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE my_ip_addresses (\n    prefix String,\n    asn UInt32,\n    cca2 String\n)\nENGINE = MergeTree\nPRIMARY KEY prefix;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO my_ip_addresses VALUES\n    ('202.79.32.0/20', 17501, 'NP'),\n    ('2620:0:870::/48', 3856, 'US'),\n    ('2a02:6b8:1::/48', 13238, 'RU'),\n    ('2001:db8::/32', 65536, 'ZZ')\n;\n")),(0,i.kt)("p",null,"Let's define an ",(0,i.kt)("inlineCode",{parentName:"p"},"ip_trie")," dictionary for this table. The ",(0,i.kt)("inlineCode",{parentName:"p"},"ip_trie")," layout requires a composite key:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"<structure>\n    <key>\n        <attribute>\n            <name>prefix</name>\n            <type>String</type>\n        </attribute>\n    </key>\n    <attribute>\n            <name>asn</name>\n            <type>UInt32</type>\n            <null_value />\n    </attribute>\n    <attribute>\n            <name>cca2</name>\n            <type>String</type>\n            <null_value>??</null_value>\n    </attribute>\n    ...\n</structure>\n<layout>\n    <ip_trie>\n        \x3c!-- Key attribute `prefix` can be retrieved via dictGetString. --\x3e\n        \x3c!-- This option increases memory usage. --\x3e\n        <access_to_key_from_attributes>true</access_to_key_from_attributes>\n    </ip_trie>\n</layout>\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE DICTIONARY my_ip_trie_dictionary (\n    prefix String,\n    asn UInt32,\n    cca2 String DEFAULT '??'\n)\nPRIMARY KEY prefix\nSOURCE(CLICKHOUSE(TABLE 'my_ip_addresses'))\nLAYOUT(IP_TRIE)\nLIFETIME(3600);\n")),(0,i.kt)("p",null,"The key must have only one ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," type attribute that contains an allowed IP prefix. Other types are not supported yet."),(0,i.kt)("p",null,"For queries, you must use the same functions (",(0,i.kt)("inlineCode",{parentName:"p"},"dictGetT")," with a tuple) as for dictionaries with composite keys. The syntax is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"dictGetT('dict_name', 'attr_name', tuple(ip))\n")),(0,i.kt)("p",null,"The function takes either ",(0,i.kt)("inlineCode",{parentName:"p"},"UInt32")," for IPv4, or ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedString(16)")," for IPv6. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select dictGet('my_ip_trie_dictionary', 'asn', tuple(IPv6StringToNum('2001:db8::1')))\n")),(0,i.kt)("p",null,"Other types are not supported yet. The function returns the attribute for the prefix that corresponds to this IP address. If there are overlapping prefixes, the most specific one is returned."),(0,i.kt)("p",null,"Data must completely fit into RAM."),(0,i.kt)("h2",{id:"related-content"},"Related Content"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://clickhouse.com/blog/faster-queries-dictionaries-clickhouse"},"Using dictionaries to accelerate queries"))))}m.isMDXComponent=!0}}]);